<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StanfordCPPLib: BasicGraphGen&lt; V, E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StanfordCPPLib
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classBasicGraphGen-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BasicGraphGen&lt; V, E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>BasicGraph is just basically an instantiation of <a class="el" href="classGraph.html" title="This class represents a graph with the specified node and arc types. ">Graph</a> using Vertex and Edge as its template parameters.  
 <a href="classBasicGraphGen.html#details">More...</a></p>

<p><code>#include "<a class="el" href="basicgraph_8h_source.html">basicgraph.h</a>"</code></p>
<div class="dynheader">
Inheritance diagram for BasicGraphGen&lt; V, E &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classBasicGraphGen.png" usemap="#BasicGraphGen_3C_20V_2C_20E_20_3E_map" alt=""/>
  <map id="BasicGraphGen_3C_20V_2C_20E_20_3E_map" name="BasicGraphGen_3C_20V_2C_20E_20_3E_map">
<area href="classGraph.html" alt="Graph&lt; VertexGen&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt;" shape="rect" coords="0,0,292,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a695969c31e87f9e8319d74e5ca39024b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> = typename <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&gt;::const_iterator</td></tr>
<tr class="separator:a695969c31e87f9e8319d74e5ca39024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d6eaee0a2e8ea6de432f815463813fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a9d6eaee0a2e8ea6de432f815463813fa">BasicGraphGen</a>()</td></tr>
<tr class="memdesc:a9d6eaee0a2e8ea6de432f815463813fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new empty graph.  <a href="#a9d6eaee0a2e8ea6de432f815463813fa">More...</a><br /></td></tr>
<tr class="separator:a9d6eaee0a2e8ea6de432f815463813fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8af075f69d803e4a813e4d348150fc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#aa8af075f69d803e4a813e4d348150fc5">BasicGraphGen</a>(std::initializer_list&lt; string &gt; vertexList)</td></tr>
<tr class="memdesc:aa8af075f69d803e4a813e4d348150fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new graph containing the given vertexes.  <a href="#aa8af075f69d803e4a813e4d348150fc5">More...</a><br /></td></tr>
<tr class="separator:aa8af075f69d803e4a813e4d348150fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e9fedd7110ae2fb6873c5e2d29941"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aad2e9fedd7110ae2fb6873c5e2d29941">addArc</a>(string n1, string n2)</td></tr>
<tr class="memdesc:aad2e9fedd7110ae2fb6873c5e2d29941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed arc to the graph from node n1 to n2.  <a href="#aad2e9fedd7110ae2fb6873c5e2d29941">More...</a><br /></td></tr>
<tr class="separator:aad2e9fedd7110ae2fb6873c5e2d29941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280d3cd76bab82df392ba91ed5257c6"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7280d3cd76bab82df392ba91ed5257c6">addArc</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *n1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *n2)</td></tr>
<tr class="memdesc:a7280d3cd76bab82df392ba91ed5257c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed arc to the graph from node n1 to n2.  <a href="#a7280d3cd76bab82df392ba91ed5257c6">More...</a><br /></td></tr>
<tr class="separator:a7280d3cd76bab82df392ba91ed5257c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b6553e579c03260253a2d731668dfa"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa1b6553e579c03260253a2d731668dfa">addArc</a>(EdgeGen&lt; V, E &gt; *arc)</td></tr>
<tr class="memdesc:aa1b6553e579c03260253a2d731668dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given arc to the graph.  <a href="#aa1b6553e579c03260253a2d731668dfa">More...</a><br /></td></tr>
<tr class="separator:aa1b6553e579c03260253a2d731668dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624c45bedf3986073b0f8a40ab4d85c2"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a624c45bedf3986073b0f8a40ab4d85c2">addEdge</a>(string v1, string v2, double cost=0.0, bool directed=true)</td></tr>
<tr class="memdesc:a624c45bedf3986073b0f8a40ab4d85c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge to the graph from vertex v1 to vertex v2.  <a href="#a624c45bedf3986073b0f8a40ab4d85c2">More...</a><br /></td></tr>
<tr class="separator:a624c45bedf3986073b0f8a40ab4d85c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fe8fab4722e89853df8ed385aa7a26"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ac2fe8fab4722e89853df8ed385aa7a26">addEdge</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v2, double cost=0.0, bool directed=true)</td></tr>
<tr class="memdesc:ac2fe8fab4722e89853df8ed385aa7a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge to the graph from vertex v1 to vertex v2.  <a href="#ac2fe8fab4722e89853df8ed385aa7a26">More...</a><br /></td></tr>
<tr class="separator:ac2fe8fab4722e89853df8ed385aa7a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cffe0dd5b70ab78a3bce486fd60637"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a92cffe0dd5b70ab78a3bce486fd60637">addEdge</a>(EdgeGen&lt; V, E &gt; *e, bool directed=true)</td></tr>
<tr class="memdesc:a92cffe0dd5b70ab78a3bce486fd60637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given directed edge to the graph from vertex v1 to vertex v2.  <a href="#a92cffe0dd5b70ab78a3bce486fd60637">More...</a><br /></td></tr>
<tr class="separator:a92cffe0dd5b70ab78a3bce486fd60637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd763aa09491315536b5d2734cd82b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acd763aa09491315536b5d2734cd82b89">addNode</a>(string name)</td></tr>
<tr class="memdesc:acd763aa09491315536b5d2734cd82b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph.  <a href="#acd763aa09491315536b5d2734cd82b89">More...</a><br /></td></tr>
<tr class="separator:acd763aa09491315536b5d2734cd82b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635fa78d72315816cef6c091acfa3882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a635fa78d72315816cef6c091acfa3882">addNode</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node)</td></tr>
<tr class="memdesc:a635fa78d72315816cef6c091acfa3882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph.  <a href="#a635fa78d72315816cef6c091acfa3882">More...</a><br /></td></tr>
<tr class="separator:a635fa78d72315816cef6c091acfa3882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f19882208c6d1dc51b74d5f348f458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a60f19882208c6d1dc51b74d5f348f458">addVertex</a>(string name)</td></tr>
<tr class="memdesc:a60f19882208c6d1dc51b74d5f348f458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph, if no vertex with that name already exists in the graph.  <a href="#a60f19882208c6d1dc51b74d5f348f458">More...</a><br /></td></tr>
<tr class="separator:a60f19882208c6d1dc51b74d5f348f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99facea785e991d862eef401807c5f79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a99facea785e991d862eef401807c5f79">addVertex</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v)</td></tr>
<tr class="memdesc:a99facea785e991d862eef401807c5f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph, if no vertex with that name already exists in the graph.  <a href="#a99facea785e991d862eef401807c5f79">More...</a><br /></td></tr>
<tr class="separator:a99facea785e991d862eef401807c5f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b108b3354f5222d2c829dcd639fa7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0b108b3354f5222d2c829dcd639fa7a">arcCount</a>() const</td></tr>
<tr class="memdesc:ac0b108b3354f5222d2c829dcd639fa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arcs in the graph.  <a href="#ac0b108b3354f5222d2c829dcd639fa7a">More...</a><br /></td></tr>
<tr class="separator:ac0b108b3354f5222d2c829dcd639fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d59ef129bb56cc144ecc81c0affd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a27d59ef129bb56cc144ecc81c0affd34">back</a>() const</td></tr>
<tr class="memdesc:a27d59ef129bb56cc144ecc81c0affd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last node in the graph in the order as would be returned by a for-each loop or iterator.  <a href="#a27d59ef129bb56cc144ecc81c0affd34">More...</a><br /></td></tr>
<tr class="separator:a27d59ef129bb56cc144ecc81c0affd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a8950c46f4ac913207201b685e715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aea3a8950c46f4ac913207201b685e715">begin</a>() const</td></tr>
<tr class="memdesc:aea3a8950c46f4ac913207201b685e715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an STL iterator positioned at the first vertex in the graph.  <a href="#aea3a8950c46f4ac913207201b685e715">More...</a><br /></td></tr>
<tr class="separator:aea3a8950c46f4ac913207201b685e715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the graph to be empty, removing all nodes and arcs and freeing any heap storage used by their corresponding internal structures.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0ce1806df1c8070d997153363eecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a63f0ce1806df1c8070d997153363eecb">clearArcs</a>()</td></tr>
<tr class="memdesc:a63f0ce1806df1c8070d997153363eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all arcs from the graph, freeing the heap storage used by their corresponding internal structures.  <a href="#a63f0ce1806df1c8070d997153363eecb">More...</a><br /></td></tr>
<tr class="separator:a63f0ce1806df1c8070d997153363eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14def9e68896088fec7839e5da4fed27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a14def9e68896088fec7839e5da4fed27">clearArcs</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node)</td></tr>
<tr class="memdesc:a14def9e68896088fec7839e5da4fed27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures.  <a href="#a14def9e68896088fec7839e5da4fed27">More...</a><br /></td></tr>
<tr class="separator:a14def9e68896088fec7839e5da4fed27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8ecb9c6768fff244b2be46319385cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2d8ecb9c6768fff244b2be46319385cc">clearArcs</a>(string name)</td></tr>
<tr class="memdesc:a2d8ecb9c6768fff244b2be46319385cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures.  <a href="#a2d8ecb9c6768fff244b2be46319385cc">More...</a><br /></td></tr>
<tr class="separator:a2d8ecb9c6768fff244b2be46319385cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced46bbfe5973602cbd67ac6188c36db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#aced46bbfe5973602cbd67ac6188c36db">clearEdges</a>()</td></tr>
<tr class="memdesc:aced46bbfe5973602cbd67ac6188c36db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all edges from the graph.  <a href="#aced46bbfe5973602cbd67ac6188c36db">More...</a><br /></td></tr>
<tr class="separator:aced46bbfe5973602cbd67ac6188c36db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3104a246e5eaa7701c96bf52038c6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ac3104a246e5eaa7701c96bf52038c6b0">clearEdges</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v)</td></tr>
<tr class="memdesc:ac3104a246e5eaa7701c96bf52038c6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all outbound edges of the given vertex from the graph.  <a href="#ac3104a246e5eaa7701c96bf52038c6b0">More...</a><br /></td></tr>
<tr class="separator:ac3104a246e5eaa7701c96bf52038c6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c104818fb8653db07b7f4a3d5fe11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a206c104818fb8653db07b7f4a3d5fe11">clearEdges</a>(string v)</td></tr>
<tr class="memdesc:a206c104818fb8653db07b7f4a3d5fe11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all outbound edges of the given vertex from the graph.  <a href="#a206c104818fb8653db07b7f4a3d5fe11">More...</a><br /></td></tr>
<tr class="separator:a206c104818fb8653db07b7f4a3d5fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca50139471975b82fdc6b1977bcfa4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9ca50139471975b82fdc6b1977bcfa4a">containsArc</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node2) const</td></tr>
<tr class="memdesc:a9ca50139471975b82fdc6b1977bcfa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists an arc directly between the given two nodes.  <a href="#a9ca50139471975b82fdc6b1977bcfa4a">More...</a><br /></td></tr>
<tr class="separator:a9ca50139471975b82fdc6b1977bcfa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515e45aae316b581bf1cf168541f4f44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a515e45aae316b581bf1cf168541f4f44">containsArc</a>(string node1, string node2) const</td></tr>
<tr class="memdesc:a515e45aae316b581bf1cf168541f4f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists an arc directly between the given two nodes.  <a href="#a515e45aae316b581bf1cf168541f4f44">More...</a><br /></td></tr>
<tr class="separator:a515e45aae316b581bf1cf168541f4f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a659ddd8a143836b91b01c200ee8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acf7a659ddd8a143836b91b01c200ee8a">containsArc</a>(EdgeGen&lt; V, E &gt; *arc) const</td></tr>
<tr class="memdesc:acf7a659ddd8a143836b91b01c200ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given arc exists in this graph.  <a href="#acf7a659ddd8a143836b91b01c200ee8a">More...</a><br /></td></tr>
<tr class="separator:acf7a659ddd8a143836b91b01c200ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce3804a90bf7006e7bc78e1a51a1365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a6ce3804a90bf7006e7bc78e1a51a1365">containsEdge</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v2) const</td></tr>
<tr class="memdesc:a6ce3804a90bf7006e7bc78e1a51a1365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph has an edge from v1 to v2 in the graph.  <a href="#a6ce3804a90bf7006e7bc78e1a51a1365">More...</a><br /></td></tr>
<tr class="separator:a6ce3804a90bf7006e7bc78e1a51a1365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4475808d2ed8a45b9fceecc2c6081fc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a4475808d2ed8a45b9fceecc2c6081fc3">containsEdge</a>(string v1, string v2) const</td></tr>
<tr class="memdesc:a4475808d2ed8a45b9fceecc2c6081fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph has an edge from v1 to v2 in the graph.  <a href="#a4475808d2ed8a45b9fceecc2c6081fc3">More...</a><br /></td></tr>
<tr class="separator:a4475808d2ed8a45b9fceecc2c6081fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41e772ab382972e1c54ab6df781dd82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ad41e772ab382972e1c54ab6df781dd82">containsEdge</a>(EdgeGen&lt; V, E &gt; *edge) const</td></tr>
<tr class="memdesc:ad41e772ab382972e1c54ab6df781dd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph contains the given edge.  <a href="#ad41e772ab382972e1c54ab6df781dd82">More...</a><br /></td></tr>
<tr class="separator:ad41e772ab382972e1c54ab6df781dd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0beb77e8a238c2898ab851df71eeefe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0beb77e8a238c2898ab851df71eeefe">containsNode</a>(string name) const</td></tr>
<tr class="memdesc:ac0beb77e8a238c2898ab851df71eeefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a node in this graph with the given name.  <a href="#ac0beb77e8a238c2898ab851df71eeefe">More...</a><br /></td></tr>
<tr class="separator:ac0beb77e8a238c2898ab851df71eeefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f540ebc07c4e46a0bb7fee76a93386c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4f540ebc07c4e46a0bb7fee76a93386c">containsNode</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:a4f540ebc07c4e46a0bb7fee76a93386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is part of this graph.  <a href="#a4f540ebc07c4e46a0bb7fee76a93386c">More...</a><br /></td></tr>
<tr class="separator:a4f540ebc07c4e46a0bb7fee76a93386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6062ac98f3491a525e0809c5b03b7cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ab6062ac98f3491a525e0809c5b03b7cf">containsVertex</a>(string name) const</td></tr>
<tr class="memdesc:ab6062ac98f3491a525e0809c5b03b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the graph contains a vertex with the given name.  <a href="#ab6062ac98f3491a525e0809c5b03b7cf">More...</a><br /></td></tr>
<tr class="separator:ab6062ac98f3491a525e0809c5b03b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d4f31bc5bb6397fdb0bf966b54ca3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a37d4f31bc5bb6397fdb0bf966b54ca3f">containsVertex</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v) const</td></tr>
<tr class="memdesc:a37d4f31bc5bb6397fdb0bf966b54ca3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the graph contains the given vertex.  <a href="#a37d4f31bc5bb6397fdb0bf966b54ca3f">More...</a><br /></td></tr>
<tr class="separator:a37d4f31bc5bb6397fdb0bf966b54ca3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f43093f29e66e171d5f572a658ae0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#aa1f43093f29e66e171d5f572a658ae0c">edgeCount</a>() const</td></tr>
<tr class="memdesc:aa1f43093f29e66e171d5f572a658ae0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges in the graph.  <a href="#aa1f43093f29e66e171d5f572a658ae0c">More...</a><br /></td></tr>
<tr class="separator:aa1f43093f29e66e171d5f572a658ae0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf62cae5d7e50644957d66f886742d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afcdf62cae5d7e50644957d66f886742d">end</a>() const</td></tr>
<tr class="memdesc:afcdf62cae5d7e50644957d66f886742d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an STL iterator positioned after the last vertex in the graph.  <a href="#afcdf62cae5d7e50644957d66f886742d">More...</a><br /></td></tr>
<tr class="separator:afcdf62cae5d7e50644957d66f886742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bec43eb3dfdf3d23eb328b406edf44a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6bec43eb3dfdf3d23eb328b406edf44a">equals</a>(const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;graph2) const</td></tr>
<tr class="memdesc:a6bec43eb3dfdf3d23eb328b406edf44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two graphs for equality.  <a href="#a6bec43eb3dfdf3d23eb328b406edf44a">More...</a><br /></td></tr>
<tr class="separator:a6bec43eb3dfdf3d23eb328b406edf44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7c2c1738f8e7faf84c54d7642992fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7b7c2c1738f8e7faf84c54d7642992fa">front</a>() const</td></tr>
<tr class="memdesc:a7b7c2c1738f8e7faf84c54d7642992fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first node in the graph in the order as would be returned by a for-each loop or iterator.  <a href="#a7b7c2c1738f8e7faf84c54d7642992fa">More...</a><br /></td></tr>
<tr class="separator:a7b7c2c1738f8e7faf84c54d7642992fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33db338f839ff9e3dafe4fe61c16fd"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7c33db338f839ff9e3dafe4fe61c16fd">getArc</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node2) const</td></tr>
<tr class="memdesc:a7c33db338f839ff9e3dafe4fe61c16fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arc, if any, from node1 to node2.  <a href="#a7c33db338f839ff9e3dafe4fe61c16fd">More...</a><br /></td></tr>
<tr class="separator:a7c33db338f839ff9e3dafe4fe61c16fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4badfc856b0d4530c37121efb9834"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a94d4badfc856b0d4530c37121efb9834">getArc</a>(string node1, string node2) const</td></tr>
<tr class="memdesc:a94d4badfc856b0d4530c37121efb9834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arc, if any, from node1 to node2.  <a href="#a94d4badfc856b0d4530c37121efb9834">More...</a><br /></td></tr>
<tr class="separator:a94d4badfc856b0d4530c37121efb9834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0690edaeae8d5256189ae2e8541788b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; *&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0690edaeae8d5256189ae2e8541788b5">getArcSet</a>() const</td></tr>
<tr class="memdesc:a0690edaeae8d5256189ae2e8541788b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all arcs in the graph.  <a href="#a0690edaeae8d5256189ae2e8541788b5">More...</a><br /></td></tr>
<tr class="separator:a0690edaeae8d5256189ae2e8541788b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cfc7f4d8c738fc6f51813f50be6400"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; *&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a17cfc7f4d8c738fc6f51813f50be6400">getArcSet</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:a17cfc7f4d8c738fc6f51813f50be6400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all arcs that start at the specified node, indicated as a pointer to its node structure.  <a href="#a17cfc7f4d8c738fc6f51813f50be6400">More...</a><br /></td></tr>
<tr class="separator:a17cfc7f4d8c738fc6f51813f50be6400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9e2056ee2d66a7ea9feb02f016e8d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; *&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a31b9e2056ee2d66a7ea9feb02f016e8d">getArcSet</a>(string name) const</td></tr>
<tr class="memdesc:a31b9e2056ee2d66a7ea9feb02f016e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all arcs that start at the specified node.  <a href="#a31b9e2056ee2d66a7ea9feb02f016e8d">More...</a><br /></td></tr>
<tr class="separator:a31b9e2056ee2d66a7ea9feb02f016e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad31ac511c91ccf23a19af68e7a9f316"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#aad31ac511c91ccf23a19af68e7a9f316">getEdge</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v2) const</td></tr>
<tr class="memdesc:aad31ac511c91ccf23a19af68e7a9f316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the structure representing the edge from v1 to v2 in the graph.  <a href="#aad31ac511c91ccf23a19af68e7a9f316">More...</a><br /></td></tr>
<tr class="separator:aad31ac511c91ccf23a19af68e7a9f316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e156a4bae200f10f36fce5ec7fe504"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a57e156a4bae200f10f36fce5ec7fe504">getEdge</a>(string v1, string v2) const</td></tr>
<tr class="memdesc:a57e156a4bae200f10f36fce5ec7fe504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the structure representing the edge from v1 to v2 in the graph.  <a href="#a57e156a4bae200f10f36fce5ec7fe504">More...</a><br /></td></tr>
<tr class="separator:a57e156a4bae200f10f36fce5ec7fe504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312cc70af3d52a9fbdd56629c1710e48"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a312cc70af3d52a9fbdd56629c1710e48">getEdgeSet</a>() const</td></tr>
<tr class="memdesc:a312cc70af3d52a9fbdd56629c1710e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all edges in the graph.  <a href="#a312cc70af3d52a9fbdd56629c1710e48">More...</a><br /></td></tr>
<tr class="separator:a312cc70af3d52a9fbdd56629c1710e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe8d6cbb48312f7fbec0fd948330348"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#abfe8d6cbb48312f7fbec0fd948330348">getEdgeSet</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v) const</td></tr>
<tr class="memdesc:abfe8d6cbb48312f7fbec0fd948330348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all edges that start at the specified vertex.  <a href="#abfe8d6cbb48312f7fbec0fd948330348">More...</a><br /></td></tr>
<tr class="separator:abfe8d6cbb48312f7fbec0fd948330348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deea7a4536dfd6346c62c0c05a141ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a6deea7a4536dfd6346c62c0c05a141ed">getEdgeSet</a>(string v) const</td></tr>
<tr class="memdesc:a6deea7a4536dfd6346c62c0c05a141ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all edges that start at the specified vertex.  <a href="#a6deea7a4536dfd6346c62c0c05a141ed">More...</a><br /></td></tr>
<tr class="separator:a6deea7a4536dfd6346c62c0c05a141ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e645c23a9816fff136e0a5f7941669"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ad8e645c23a9816fff136e0a5f7941669">getInverseArc</a>(EdgeGen&lt; V, E &gt; *edge) const</td></tr>
<tr class="memdesc:ad8e645c23a9816fff136e0a5f7941669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edge that is the opposite of the given edge; that is, if the specified edge e starts at v1 and ends at v2, will return the edge that starts at v2 and ends at v1, if such an edge exists in the graph.  <a href="#ad8e645c23a9816fff136e0a5f7941669">More...</a><br /></td></tr>
<tr class="separator:ad8e645c23a9816fff136e0a5f7941669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fd149800cd46aae497b05b46059b63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad5fd149800cd46aae497b05b46059b63">getInverseArcSet</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:ad5fd149800cd46aae497b05b46059b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of outbound arcs to the given node from other nodes.  <a href="#ad5fd149800cd46aae497b05b46059b63">More...</a><br /></td></tr>
<tr class="separator:ad5fd149800cd46aae497b05b46059b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfe12e71ca594736a1e329461cff024"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2cfe12e71ca594736a1e329461cff024">getInverseArcSet</a>(string name) const</td></tr>
<tr class="memdesc:a2cfe12e71ca594736a1e329461cff024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of outbound arcs to the given node from other nodes.  <a href="#a2cfe12e71ca594736a1e329461cff024">More...</a><br /></td></tr>
<tr class="separator:a2cfe12e71ca594736a1e329461cff024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81616e12d12f2dcfa295b4a3b48f960"><td class="memItemLeft" align="right" valign="top">EdgeGen&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ae81616e12d12f2dcfa295b4a3b48f960">getInverseEdge</a>(EdgeGen&lt; V, E &gt; *edge) const</td></tr>
<tr class="memdesc:ae81616e12d12f2dcfa295b4a3b48f960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edge that is the opposite of the given edge; that is, if the specified edge e starts at v1 and ends at v2, will return the edge that starts at v2 and ends at v1, if such an edge exists in the graph.  <a href="#ae81616e12d12f2dcfa295b4a3b48f960">More...</a><br /></td></tr>
<tr class="separator:ae81616e12d12f2dcfa295b4a3b48f960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db8788e3783e8ff16b19c06a5f2cf62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a5db8788e3783e8ff16b19c06a5f2cf62">getInverseEdgeSet</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v) const</td></tr>
<tr class="memdesc:a5db8788e3783e8ff16b19c06a5f2cf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all edges in the graph that end at the specified vertex.  <a href="#a5db8788e3783e8ff16b19c06a5f2cf62">More...</a><br /></td></tr>
<tr class="separator:a5db8788e3783e8ff16b19c06a5f2cf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef9596e6faf68669228bc69808e84bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a7ef9596e6faf68669228bc69808e84bd">getInverseEdgeSet</a>(string v) const</td></tr>
<tr class="memdesc:a7ef9596e6faf68669228bc69808e84bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all edges in the graph that end at the specified vertex.  <a href="#a7ef9596e6faf68669228bc69808e84bd">More...</a><br /></td></tr>
<tr class="separator:a7ef9596e6faf68669228bc69808e84bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eceee00e824ea4852449fa3de61e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa9eceee00e824ea4852449fa3de61e82">getInverseNeighborNames</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:aa9eceee00e824ea4852449fa3de61e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of strings of names of nodes that are neighbors of the given node.  <a href="#aa9eceee00e824ea4852449fa3de61e82">More...</a><br /></td></tr>
<tr class="separator:aa9eceee00e824ea4852449fa3de61e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc36bc1eb0f249180cfe78bce6e7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac3dc36bc1eb0f249180cfe78bce6e7a2">getInverseNeighborNames</a>(string node) const</td></tr>
<tr class="memdesc:ac3dc36bc1eb0f249180cfe78bce6e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of strings of names of nodes that are neighbors of the given node.  <a href="#ac3dc36bc1eb0f249180cfe78bce6e7a2">More...</a><br /></td></tr>
<tr class="separator:ac3dc36bc1eb0f249180cfe78bce6e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a5724c594b9bd0b6008c57b09af317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a80a5724c594b9bd0b6008c57b09af317">getInverseNeighbors</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:a80a5724c594b9bd0b6008c57b09af317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a80a5724c594b9bd0b6008c57b09af317">More...</a><br /></td></tr>
<tr class="separator:a80a5724c594b9bd0b6008c57b09af317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5294846b9cdd19394808e3736ec67004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5294846b9cdd19394808e3736ec67004">getInverseNeighbors</a>(string node) const</td></tr>
<tr class="memdesc:a5294846b9cdd19394808e3736ec67004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a5294846b9cdd19394808e3736ec67004">More...</a><br /></td></tr>
<tr class="separator:a5294846b9cdd19394808e3736ec67004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae9b5cbd2bcb3918c4c64b1eb71c1a3a8">getNeighborNames</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of node names that are neighbors of the specified node.  <a href="#ae9b5cbd2bcb3918c4c64b1eb71c1a3a8">More...</a><br /></td></tr>
<tr class="separator:ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6175b4d672266465dd34e070c7710b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6175b4d672266465dd34e070c7710b34">getNeighborNames</a>(string node) const</td></tr>
<tr class="memdesc:a6175b4d672266465dd34e070c7710b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of node names that are neighbors of the specified node.  <a href="#a6175b4d672266465dd34e070c7710b34">More...</a><br /></td></tr>
<tr class="separator:a6175b4d672266465dd34e070c7710b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e49b167f0623a8ae76040c3e5eab3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0e49b167f0623a8ae76040c3e5eab3fb">getNeighbors</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node) const</td></tr>
<tr class="memdesc:a0e49b167f0623a8ae76040c3e5eab3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a0e49b167f0623a8ae76040c3e5eab3fb">More...</a><br /></td></tr>
<tr class="separator:a0e49b167f0623a8ae76040c3e5eab3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3720906c380f36b50530419330bfe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3a3720906c380f36b50530419330bfe5">getNeighbors</a>(string node) const</td></tr>
<tr class="memdesc:a3a3720906c380f36b50530419330bfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a3a3720906c380f36b50530419330bfe5">More...</a><br /></td></tr>
<tr class="separator:a3a3720906c380f36b50530419330bfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81487976cf0e576047333c85463c33aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a81487976cf0e576047333c85463c33aa">getNode</a>(string name) const</td></tr>
<tr class="memdesc:a81487976cf0e576047333c85463c33aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a node in the name table attached to the graph and returns a pointer to that node.  <a href="#a81487976cf0e576047333c85463c33aa">More...</a><br /></td></tr>
<tr class="separator:a81487976cf0e576047333c85463c33aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6f37932f377dd2bf4fec61343a916d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3c6f37932f377dd2bf4fec61343a916d">getNodeNames</a>() const</td></tr>
<tr class="memdesc:a3c6f37932f377dd2bf4fec61343a916d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of the names of all nodes in the graph.  <a href="#a3c6f37932f377dd2bf4fec61343a916d">More...</a><br /></td></tr>
<tr class="separator:a3c6f37932f377dd2bf4fec61343a916d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5552888f57aaa581099e8146c617c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abd5552888f57aaa581099e8146c617c9">getNodeSet</a>() const</td></tr>
<tr class="memdesc:abd5552888f57aaa581099e8146c617c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all nodes in the graph.  <a href="#abd5552888f57aaa581099e8146c617c9">More...</a><br /></td></tr>
<tr class="separator:abd5552888f57aaa581099e8146c617c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0c055103d2adba54014d301ae7bd1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a4c0c055103d2adba54014d301ae7bd1c">getVertex</a>(string name) const</td></tr>
<tr class="memdesc:a4c0c055103d2adba54014d301ae7bd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a vertex in the graph by name and returns a pointer to its internal data structure.  <a href="#a4c0c055103d2adba54014d301ae7bd1c">More...</a><br /></td></tr>
<tr class="separator:a4c0c055103d2adba54014d301ae7bd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bca1f87888bd787f836bc064a9ff01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ae1bca1f87888bd787f836bc064a9ff01">getVertexNames</a>() const</td></tr>
<tr class="memdesc:ae1bca1f87888bd787f836bc064a9ff01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of the names of all vertexes in the graph.  <a href="#ae1bca1f87888bd787f836bc064a9ff01">More...</a><br /></td></tr>
<tr class="separator:ae1bca1f87888bd787f836bc064a9ff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec896ef5b1fc6044fc71318d1369f6f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#aec896ef5b1fc6044fc71318d1369f6f1">getVertexSet</a>() const</td></tr>
<tr class="memdesc:aec896ef5b1fc6044fc71318d1369f6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all vertexes in the graph.  <a href="#aec896ef5b1fc6044fc71318d1369f6f1">More...</a><br /></td></tr>
<tr class="separator:aec896ef5b1fc6044fc71318d1369f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54164ab847f3a5c7fe15d15ac95af443"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a54164ab847f3a5c7fe15d15ac95af443">isConnected</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *n1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *n2) const</td></tr>
<tr class="memdesc:a54164ab847f3a5c7fe15d15ac95af443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>.  <a href="#a54164ab847f3a5c7fe15d15ac95af443">More...</a><br /></td></tr>
<tr class="separator:a54164ab847f3a5c7fe15d15ac95af443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3623b7decbedc522041c2c39d3b14421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3623b7decbedc522041c2c39d3b14421">isConnected</a>(string s1, string s2) const</td></tr>
<tr class="memdesc:a3623b7decbedc522041c2c39d3b14421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>.  <a href="#a3623b7decbedc522041c2c39d3b14421">More...</a><br /></td></tr>
<tr class="separator:a3623b7decbedc522041c2c39d3b14421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a>() const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the graph contains no vertexes.  <a href="#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab160bb64995133f6feb351cb23b031fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab160bb64995133f6feb351cb23b031fb">isNeighbor</a>(string node1, string node2) const</td></tr>
<tr class="memdesc:ab160bb64995133f6feb351cb23b031fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph contains an edge from v1 to v2.  <a href="#ab160bb64995133f6feb351cb23b031fb">More...</a><br /></td></tr>
<tr class="separator:ab160bb64995133f6feb351cb23b031fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e752628a118c4a06a538067c95bbb28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9e752628a118c4a06a538067c95bbb28">isNeighbor</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node2) const</td></tr>
<tr class="memdesc:a9e752628a118c4a06a538067c95bbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph contains an edge from v1 to v2.  <a href="#a9e752628a118c4a06a538067c95bbb28">More...</a><br /></td></tr>
<tr class="separator:a9e752628a118c4a06a538067c95bbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd1afdb4e1c75fbe51976bf6f70c922"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5dd1afdb4e1c75fbe51976bf6f70c922">nodeCount</a>() const</td></tr>
<tr class="memdesc:a5dd1afdb4e1c75fbe51976bf6f70c922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph.  <a href="#a5dd1afdb4e1c75fbe51976bf6f70c922">More...</a><br /></td></tr>
<tr class="separator:a5dd1afdb4e1c75fbe51976bf6f70c922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd8d1cec3a4d6b8cdcb58016e4d093a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aafd8d1cec3a4d6b8cdcb58016e4d093a">operator!=</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:aafd8d1cec3a4d6b8cdcb58016e4d093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#aafd8d1cec3a4d6b8cdcb58016e4d093a">More...</a><br /></td></tr>
<tr class="separator:aafd8d1cec3a4d6b8cdcb58016e4d093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daf423faecc777e29a399812dc39ca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1daf423faecc777e29a399812dc39ca2">operator&lt;</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a1daf423faecc777e29a399812dc39ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a1daf423faecc777e29a399812dc39ca2">More...</a><br /></td></tr>
<tr class="separator:a1daf423faecc777e29a399812dc39ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352607f2b21dd87b3d2a3957bbf3da7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a352607f2b21dd87b3d2a3957bbf3da7b">operator&lt;=</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a352607f2b21dd87b3d2a3957bbf3da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a352607f2b21dd87b3d2a3957bbf3da7b">More...</a><br /></td></tr>
<tr class="separator:a352607f2b21dd87b3d2a3957bbf3da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188f85939e3fe6ed2d411f622287f722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a188f85939e3fe6ed2d411f622287f722">operator==</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a188f85939e3fe6ed2d411f622287f722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a188f85939e3fe6ed2d411f622287f722">More...</a><br /></td></tr>
<tr class="separator:a188f85939e3fe6ed2d411f622287f722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8019cf2c98949fd509193cf26ba2ff8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8019cf2c98949fd509193cf26ba2ff8a">operator&gt;</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a8019cf2c98949fd509193cf26ba2ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a8019cf2c98949fd509193cf26ba2ff8a">More...</a><br /></td></tr>
<tr class="separator:a8019cf2c98949fd509193cf26ba2ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ca2af20f3b0251972b72295270212e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab1ca2af20f3b0251972b72295270212e">operator&gt;=</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:ab1ca2af20f3b0251972b72295270212e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#ab1ca2af20f3b0251972b72295270212e">More...</a><br /></td></tr>
<tr class="separator:ab1ca2af20f3b0251972b72295270212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e874dbb2f9f2c7f98ec74f00790eb0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a5e874dbb2f9f2c7f98ec74f00790eb0e">operator[]</a>(string name)</td></tr>
<tr class="memdesc:a5e874dbb2f9f2c7f98ec74f00790eb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads <code>[]</code> to return vertex pointers by vertex name.  <a href="#a5e874dbb2f9f2c7f98ec74f00790eb0e">More...</a><br /></td></tr>
<tr class="separator:a5e874dbb2f9f2c7f98ec74f00790eb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91a5b6ebd034841cf4f4c410fb7ed1b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ad91a5b6ebd034841cf4f4c410fb7ed1b">operator[]</a>(string name) const</td></tr>
<tr class="memdesc:ad91a5b6ebd034841cf4f4c410fb7ed1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads <code>[]</code> to return vertex pointers by vertex name.  <a href="#ad91a5b6ebd034841cf4f4c410fb7ed1b">More...</a><br /></td></tr>
<tr class="separator:ad91a5b6ebd034841cf4f4c410fb7ed1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6370fb52d2dab4eb7795da22c33dd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af6370fb52d2dab4eb7795da22c33dd02">removeArc</a>(string s1, string s2)</td></tr>
<tr class="memdesc:af6370fb52d2dab4eb7795da22c33dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an arc from v1 to v2 in the graph, specified by the names of its endpoints.  <a href="#af6370fb52d2dab4eb7795da22c33dd02">More...</a><br /></td></tr>
<tr class="separator:af6370fb52d2dab4eb7795da22c33dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c9f44b20b49ffae9fecc0a4f156ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae0c9f44b20b49ffae9fecc0a4f156ac1">removeArc</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *n1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *n2)</td></tr>
<tr class="memdesc:ae0c9f44b20b49ffae9fecc0a4f156ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an arc from v1 to v2 in the graph, specified by the node pointers at its endpoints.  <a href="#ae0c9f44b20b49ffae9fecc0a4f156ac1">More...</a><br /></td></tr>
<tr class="separator:ae0c9f44b20b49ffae9fecc0a4f156ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6580d1b0228fe6c1a02dfe70de1abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9d6580d1b0228fe6c1a02dfe70de1abf">removeArc</a>(EdgeGen&lt; V, E &gt; *arc)</td></tr>
<tr class="memdesc:a9d6580d1b0228fe6c1a02dfe70de1abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given arc from the graph, specified as an arc pointer.  <a href="#a9d6580d1b0228fe6c1a02dfe70de1abf">More...</a><br /></td></tr>
<tr class="separator:a9d6580d1b0228fe6c1a02dfe70de1abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfee7a20d0c13cc515b3b7e951d8baf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#adfee7a20d0c13cc515b3b7e951d8baf2">removeEdge</a>(string v1, string v2, bool directed=true)</td></tr>
<tr class="memdesc:adfee7a20d0c13cc515b3b7e951d8baf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge from v1 to v2 from the graph.  <a href="#adfee7a20d0c13cc515b3b7e951d8baf2">More...</a><br /></td></tr>
<tr class="separator:adfee7a20d0c13cc515b3b7e951d8baf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1003fbe63fab20173526459fff4139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a8b1003fbe63fab20173526459fff4139">removeEdge</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v1, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v2, bool directed=true)</td></tr>
<tr class="memdesc:a8b1003fbe63fab20173526459fff4139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge from v1 to v2 from the graph.  <a href="#a8b1003fbe63fab20173526459fff4139">More...</a><br /></td></tr>
<tr class="separator:a8b1003fbe63fab20173526459fff4139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6bb1e8e2c18b7376504692f7baae62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a2c6bb1e8e2c18b7376504692f7baae62">removeEdge</a>(EdgeGen&lt; V, E &gt; *e, bool directed=true)</td></tr>
<tr class="memdesc:a2c6bb1e8e2c18b7376504692f7baae62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given edge from the graph.  <a href="#a2c6bb1e8e2c18b7376504692f7baae62">More...</a><br /></td></tr>
<tr class="separator:a2c6bb1e8e2c18b7376504692f7baae62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f7ee89176144ed4c5c6b08a233aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2d5f7ee89176144ed4c5c6b08a233aa6">removeNode</a>(string name)</td></tr>
<tr class="memdesc:a2d5f7ee89176144ed4c5c6b08a233aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node with the given name from the graph.  <a href="#a2d5f7ee89176144ed4c5c6b08a233aa6">More...</a><br /></td></tr>
<tr class="separator:a2d5f7ee89176144ed4c5c6b08a233aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfe63019975561914e0ed79551de108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2dfe63019975561914e0ed79551de108">removeNode</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *node)</td></tr>
<tr class="memdesc:a2dfe63019975561914e0ed79551de108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the graph, specified as a pointer value.  <a href="#a2dfe63019975561914e0ed79551de108">More...</a><br /></td></tr>
<tr class="separator:a2dfe63019975561914e0ed79551de108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa33b4c05ee490d241ba5542420b985b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#aaa33b4c05ee490d241ba5542420b985b">removeVertex</a>(string name)</td></tr>
<tr class="memdesc:aaa33b4c05ee490d241ba5542420b985b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given vertex from the graph.  <a href="#aaa33b4c05ee490d241ba5542420b985b">More...</a><br /></td></tr>
<tr class="separator:aaa33b4c05ee490d241ba5542420b985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eac2d17b5e8074dace019020d078acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a9eac2d17b5e8074dace019020d078acb">removeVertex</a>(<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *v)</td></tr>
<tr class="memdesc:a9eac2d17b5e8074dace019020d078acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given vertex from the graph.  <a href="#a9eac2d17b5e8074dace019020d078acb">More...</a><br /></td></tr>
<tr class="separator:a9eac2d17b5e8074dace019020d078acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4314b3b6bda0755a87e49070edd17c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a4314b3b6bda0755a87e49070edd17c3d">scanArcData</a>(<a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;scanner, EdgeGen&lt; V, E &gt; *edge, EdgeGen&lt; V, E &gt; *inverse)</td></tr>
<tr class="memdesc:a4314b3b6bda0755a87e49070edd17c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the data for an arc from the scanner.  <a href="#a4314b3b6bda0755a87e49070edd17c3d">More...</a><br /></td></tr>
<tr class="separator:a4314b3b6bda0755a87e49070edd17c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e1a05a40013ce4e4bb539d05b9937"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1c4e1a05a40013ce4e4bb539d05b9937">scanGraphEntry</a>(<a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;scanner)</td></tr>
<tr class="memdesc:a1c4e1a05a40013ce4e4bb539d05b9937"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method reads one "entry" for the graph, which is either a node description or an arc description.  <a href="#a1c4e1a05a40013ce4e4bb539d05b9937">More...</a><br /></td></tr>
<tr class="separator:a1c4e1a05a40013ce4e4bb539d05b9937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc2ca3535b7bff7759aa0c1d35ff08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0fc2ca3535b7bff7759aa0c1d35ff08b">scanNodeData</a>(<a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *)</td></tr>
<tr class="memdesc:a0fc2ca3535b7bff7759aa0c1d35ff08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the data for the specified node from the scanner.  <a href="#a0fc2ca3535b7bff7759aa0c1d35ff08b">More...</a><br /></td></tr>
<tr class="separator:a0fc2ca3535b7bff7759aa0c1d35ff08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af9593d4a5ff4274efaf429cb4f9e57cc">size</a>() const</td></tr>
<tr class="memdesc:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph.  <a href="#af9593d4a5ff4274efaf429cb4f9e57cc">More...</a><br /></td></tr>
<tr class="separator:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66498d3675a5bc08fa30a032d41764f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMap.html">Map</a>&lt; string, <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a66498d3675a5bc08fa30a032d41764f7">toMap</a>() const</td></tr>
<tr class="memdesc:a66498d3675a5bc08fa30a032d41764f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classMap.html">Map</a> representing an adjacency list equivalent to this graph.  <a href="#a66498d3675a5bc08fa30a032d41764f7">More...</a><br /></td></tr>
<tr class="separator:a66498d3675a5bc08fa30a032d41764f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1fe5121d6528fdea3f243321b3fa3a49">toString</a>() const</td></tr>
<tr class="memdesc:a1fe5121d6528fdea3f243321b3fa3a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the graph to a printable string representation.  <a href="#a1fe5121d6528fdea3f243321b3fa3a49">More...</a><br /></td></tr>
<tr class="separator:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eb4830a4800ed7704895c16a8982be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#a68eb4830a4800ed7704895c16a8982be">vertexCount</a>() const</td></tr>
<tr class="memdesc:a68eb4830a4800ed7704895c16a8982be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertexes in the graph.  <a href="#a68eb4830a4800ed7704895c16a8982be">More...</a><br /></td></tr>
<tr class="separator:a68eb4830a4800ed7704895c16a8982be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be688f4ddbd7da8eb2a8c7eef8901c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicGraphGen.html#ae7be688f4ddbd7da8eb2a8c7eef8901c">writeArcData</a>(std::ostream &amp;out, EdgeGen&lt; V, E &gt; *edge) const</td></tr>
<tr class="memdesc:ae7be688f4ddbd7da8eb2a8c7eef8901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data for the arc to the output stream.  <a href="#ae7be688f4ddbd7da8eb2a8c7eef8901c">More...</a><br /></td></tr>
<tr class="separator:ae7be688f4ddbd7da8eb2a8c7eef8901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0db5231476c8cb10655d58ebc108b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0db5231476c8cb10655d58ebc108b78">writeNodeData</a>(std::ostream &amp;, <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *) const</td></tr>
<tr class="memdesc:ac0db5231476c8cb10655d58ebc108b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data for the node to the output stream.  <a href="#ac0db5231476c8cb10655d58ebc108b78">More...</a><br /></td></tr>
<tr class="separator:ac0db5231476c8cb10655d58ebc108b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename V = void*, typename E = void*&gt;<br />
class BasicGraphGen&lt; V, E &gt;</h3>

<p>BasicGraph is just basically an instantiation of <a class="el" href="classGraph.html" title="This class represents a graph with the specified node and arc types. ">Graph</a> using Vertex and Edge as its template parameters. </p>
<p>It also adds a few convenience functions such as mirroring members like "addArc" with an equivalent more familiar name like "addEdge".</p>
<p>There are a few convenience functions related to neighbors, like isNeighbor. BasicGraph contains a DFS implementation called isReachable, not found in the normal Stanford <a class="el" href="classGraph.html" title="This class represents a graph with the specified node and arc types. ">Graph</a> class.</p>
<p>There are also a few functions added to make edges more convenient to work with: getEdge(v1, v2) to get the edge between a given pair of vertices, and getInverseEdge(edge) to get the edge v2 -&gt; v1 for a given edge v1 -&gt; v2. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a695969c31e87f9e8319d74e5ca39024b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695969c31e87f9e8319d74e5ca39024b">&#9670;&nbsp;</a></span>graph_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> =  typename <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt;<a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&gt;::const_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d6eaee0a2e8ea6de432f815463813fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6eaee0a2e8ea6de432f815463813fa">&#9670;&nbsp;</a></span>BasicGraphGen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasicGraphGen.html">BasicGraphGen</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new empty graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000001">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aa8af075f69d803e4a813e4d348150fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8af075f69d803e4a813e4d348150fc5">&#9670;&nbsp;</a></span>BasicGraphGen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBasicGraphGen.html">BasicGraphGen</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>vertexList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new graph containing the given vertexes. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000002">Big-Oh:</a></b></dt><dd>O(V) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad2e9fedd7110ae2fb6873c5e2d29941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e9fedd7110ae2fb6873c5e2d29941">&#9670;&nbsp;</a></span>addArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt;  * addArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directed arc to the graph from node n1 to n2. </p>
<p>If either node is not found in the graph, said node will be added to the graph. Returns a pointer to the arc in case the client needs to capture this value. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000042">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a7280d3cd76bab82df392ba91ed5257c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7280d3cd76bab82df392ba91ed5257c6">&#9670;&nbsp;</a></span>addArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt;  * addArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directed arc to the graph from node n1 to n2. </p>
<p>If either node is not found in the graph, said node will be added to the graph. Returns a pointer to the arc in case the client needs to capture this value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000043">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="aa1b6553e579c03260253a2d731668dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b6553e579c03260253a2d731668dfa">&#9670;&nbsp;</a></span>addArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt;  * addArc </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given arc to the graph. </p>
<p>If the start/finish nodes passed are not already part of the graph, they are added to the graph. Returns a pointer to the arc in case the client needs to capture this value.</p>
<p>Memory management: Once you hand me this ArcType* pointer, our code owns it. We will delete/free it when done with it. You do not need to (and should not) free it yourself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000044">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a624c45bedf3986073b0f8a40ab4d85c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624c45bedf3986073b0f8a40ab4d85c2">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * addEdge </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a directed edge to the graph from vertex v1 to vertex v2. </p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that it is allowed to have multiple edges between the same pair of vertexes.</p>
<p>Returns a pointer to the edge, though clients need not store that pointer; you can get the pointer again later by calling getEdge and passing the two vertexes.</p>
<p>Equivalent to addNode.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the edge created </dd></dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000003">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="ac2fe8fab4722e89853df8ed385aa7a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fe8fab4722e89853df8ed385aa7a26">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * addEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a directed edge to the graph from vertex v1 to vertex v2. </p>
<p>If either vertex is not found in the graph, said vertex will be added to the graph. <a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that it is allowed to have multiple edges between the same pair of vertexes.</p>
<p>Returns a pointer to the edge, though clients need not store that pointer; you can get the pointer again later by calling getEdge and passing the two vertexes.</p>
<p>Equivalent to addNode.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the edge created </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if either vertex is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000004">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a92cffe0dd5b70ab78a3bce486fd60637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cffe0dd5b70ab78a3bce486fd60637">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * addEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given directed edge to the graph from vertex v1 to vertex v2. </p>
<p>If either vertex is not found in the graph, said vertex will be added to the graph. <a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that it is allowed to have multiple edges between the same pair of vertexes.</p>
<p>Returns a pointer to the edge, though clients need not store that pointer; you can get the pointer again later by calling getEdge and passing the two vertexes.</p>
<p>Equivalent to addNode.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the edge created </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if either vertex is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000005">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="acd763aa09491315536b5d2734cd82b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd763aa09491315536b5d2734cd82b89">&#9670;&nbsp;</a></span>addNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * addNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node to the graph. </p>
<p>The first version of this method creates a new node of the appropriate type and initializes its fields; the second assumes that the client has already created the node and simply adds it to the graph. Returns a pointer to the node. If a node with the given name is already present, does nothing.</p>
<p>Memory management: Once you hand me this NodeType* pointer, our code owns it. We will delete/free it when done with it. You do not need to (and should not) free it yourself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000045">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a635fa78d72315816cef6c091acfa3882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635fa78d72315816cef6c091acfa3882">&#9670;&nbsp;</a></span>addNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * addNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node to the graph. </p>
<p>This version assumes that the client has already created the node structure and simply adds it to the graph. Returns a pointer to the node. If a node with the given name is already present, does nothing.</p>
<p>Memory management: Once you hand me this NodeType* pointer, our code owns it. We will delete/free it when done with it. You do not need to (and should not) free it yourself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000046">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a60f19882208c6d1dc51b74d5f348f458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f19882208c6d1dc51b74d5f348f458">&#9670;&nbsp;</a></span>addVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * addVertex </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph, if no vertex with that name already exists in the graph. </p>
<p>This version of this method accepts a string for the vertex's name, creates a new vertex of the appropriate type and initializes its fields. Returns a pointer to the vertex, though clients need not store that pointer; you can get the pointer again later by calling getVertex and passing the same name.</p>
<p>The vertexes in a graph must have unique names. If this graph already contains a vertex with the given name, the vertex will not be added and the graph's state will not change.</p>
<p>Equivalent to addNode.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the vertex created </dd></dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000006">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a99facea785e991d862eef401807c5f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99facea785e991d862eef401807c5f79">&#9670;&nbsp;</a></span>addVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * addVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph, if no vertex with that name already exists in the graph. </p>
<p>This version of this method accepts a string for the vertex's name, creates a new vertex of the appropriate type and initializes its fields. The other accepts a structure representing the vertex and its data. Returns a pointer to the vertex, though clients need not store that pointer; you can get the pointer again later by calling getVertex and passing the same name.</p>
<p>The vertexes in a graph must have unique names. If this graph already contains a vertex with the given name, the vertex will not be added and the graph's state will not change.</p>
<p>When calling this function, you are relinquishing ownership of the Vertex structure's lifecycle to the graph; our graph will free it when done with it.</p>
<p>Equivalent to addNode.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the vertex created </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if vertex is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000007">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="ac0b108b3354f5222d2c829dcd639fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b108b3354f5222d2c829dcd639fa7a">&#9670;&nbsp;</a></span>arcCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arcCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of arcs in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000047">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a27d59ef129bb56cc144ecc81c0affd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d59ef129bb56cc144ecc81c0affd34">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last node in the graph in the order as would be returned by a for-each loop or iterator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if the graph is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000048">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aea3a8950c46f4ac913207201b685e715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3a8950c46f4ac913207201b685e715">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an STL iterator positioned at the first vertex in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000091">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitializes the graph to be empty, removing all nodes and arcs and freeing any heap storage used by their corresponding internal structures. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000049">Big-Oh:</a></b></dt><dd>O(V + E) </dd></dl>

</div>
</div>
<a id="a63f0ce1806df1c8070d997153363eecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f0ce1806df1c8070d997153363eecb">&#9670;&nbsp;</a></span>clearArcs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearArcs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all arcs from the graph, freeing the heap storage used by their corresponding internal structures. </p>
<p>The graph's nodes remain intact. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000050">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a14def9e68896088fec7839e5da4fed27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14def9e68896088fec7839e5da4fed27">&#9670;&nbsp;</a></span>clearArcs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearArcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures. </p>
<p>The graph's nodes remain intact. If the given node pointer is null or not found in the graph, has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000051">Big-Oh:</a></b></dt><dd>O(log V + E) </dd></dl>

</div>
</div>
<a id="a2d8ecb9c6768fff244b2be46319385cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8ecb9c6768fff244b2be46319385cc">&#9670;&nbsp;</a></span>clearArcs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearArcs </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures. </p>
<p>The graph's nodes remain intact. If the given node is not found in the graph, has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000052">Big-Oh:</a></b></dt><dd>O(E log E) </dd></dl>

</div>
</div>
<a id="aced46bbfe5973602cbd67ac6188c36db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced46bbfe5973602cbd67ac6188c36db">&#9670;&nbsp;</a></span>clearEdges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all edges from the graph. </p>
<p>Frees any edge objects that were internally allocated as heap storage.</p>
<p>Equivalent to clearArcs. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000008">Big-Oh:</a></b></dt><dd>O(E log E) </dd></dl>

</div>
</div>
<a id="ac3104a246e5eaa7701c96bf52038c6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3104a246e5eaa7701c96bf52038c6b0">&#9670;&nbsp;</a></span>clearEdges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all outbound edges of the given vertex from the graph. </p>
<p>The vertex itself is not removed. If the vertex is null or is not found in the graph, has no effect.</p>
<p>Equivalent to clearArcs. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000009">Big-Oh:</a></b></dt><dd><p class="startdd">O(E log E) </p>
<p class="enddd">O(log V + E) </p>
</dd></dl>

</div>
</div>
<a id="a206c104818fb8653db07b7f4a3d5fe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206c104818fb8653db07b7f4a3d5fe11">&#9670;&nbsp;</a></span>clearEdges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearEdges </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all outbound edges of the given vertex from the graph. </p>
<p>The vertex itself is not removed. If the vertex is not found in the graph, has no effect.</p>
<p>Equivalent to clearArcs. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000010">Big-Oh:</a></b></dt><dd>O(E log E) </dd></dl>

</div>
</div>
<a id="a9ca50139471975b82fdc6b1977bcfa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca50139471975b82fdc6b1977bcfa4a">&#9670;&nbsp;</a></span>containsArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool containsArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists an arc directly between the given two nodes. </p>
<p>If either node is null or is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000053">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="a515e45aae316b581bf1cf168541f4f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515e45aae316b581bf1cf168541f4f44">&#9670;&nbsp;</a></span>containsArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool containsArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists an arc directly between the given two nodes. </p>
<p>If either node is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000054">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="acf7a659ddd8a143836b91b01c200ee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7a659ddd8a143836b91b01c200ee8a">&#9670;&nbsp;</a></span>containsArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool containsArc </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given arc exists in this graph. </p>
<p>If the given arc is null or either of its nodes are not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000055">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="a6ce3804a90bf7006e7bc78e1a51a1365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce3804a90bf7006e7bc78e1a51a1365">&#9670;&nbsp;</a></span>containsEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph has an edge from v1 to v2 in the graph. </p>
<p>If either of the vertexes supplied is null or is not found in the graph, returns false.</p>
<p>Equivalent to containsArc. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000011">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="a4475808d2ed8a45b9fceecc2c6081fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4475808d2ed8a45b9fceecc2c6081fc3">&#9670;&nbsp;</a></span>containsEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsEdge </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph has an edge from v1 to v2 in the graph. </p>
<p>If either of the vertexes supplied is not found in the graph, returns false.</p>
<p>Equivalent to containsArc. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000012">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="ad41e772ab382972e1c54ab6df781dd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41e772ab382972e1c54ab6df781dd82">&#9670;&nbsp;</a></span>containsEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph contains the given edge. </p>
<p>If the edge structure is null, returns false.</p>
<p>Equivalent to containsArc. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000013">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="ac0beb77e8a238c2898ab851df71eeefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0beb77e8a238c2898ab851df71eeefe">&#9670;&nbsp;</a></span>containsNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool containsNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists a node in this graph with the given name. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000056">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a4f540ebc07c4e46a0bb7fee76a93386c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f540ebc07c4e46a0bb7fee76a93386c">&#9670;&nbsp;</a></span>containsNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool containsNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given node is part of this graph. </p>
<p>If the pointer passed is null, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000057">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="ab6062ac98f3491a525e0809c5b03b7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6062ac98f3491a525e0809c5b03b7cf">&#9670;&nbsp;</a></span>containsVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsVertex </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the graph contains a vertex with the given name. </p>
<p>Equivalent to containsNode. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000014">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a37d4f31bc5bb6397fdb0bf966b54ca3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d4f31bc5bb6397fdb0bf966b54ca3f">&#9670;&nbsp;</a></span>containsVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the graph contains the given vertex. </p>
<p>If a null pointer is passed, returns false.</p>
<p>Equivalent to containsNode. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000015">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="aa1f43093f29e66e171d5f572a658ae0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f43093f29e66e171d5f572a658ae0c">&#9670;&nbsp;</a></span>edgeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int edgeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of edges in the graph. </p>
<p>Equivalent to arcCount. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000016">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="afcdf62cae5d7e50644957d66f886742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf62cae5d7e50644957d66f886742d">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an STL iterator positioned after the last vertex in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000092">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a6bec43eb3dfdf3d23eb328b406edf44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bec43eb3dfdf3d23eb328b406edf44a">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; , EdgeGen&lt; V, E &gt;  &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two graphs for equality. </p>
<p>Returns <code>true</code> if this graph contains exactly the same nodes, arcs, and connections as the given other graph. Identical in behavior to the == operator. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000058">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a7b7c2c1738f8e7faf84c54d7642992fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7c2c1738f8e7faf84c54d7642992fa">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first node in the graph in the order as would be returned by a for-each loop or iterator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if the graph is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000059">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a7c33db338f839ff9e3dafe4fe61c16fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c33db338f839ff9e3dafe4fe61c16fd">&#9670;&nbsp;</a></span>getArc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt;  * getArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the arc, if any, from node1 to node2. </p>
<p>If multiple arcs exist between the given two nodes, which is returned is unspecified. If either pointer passed is null or no such arc exists, returns a null pointer. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000060">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a94d4badfc856b0d4530c37121efb9834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d4badfc856b0d4530c37121efb9834">&#9670;&nbsp;</a></span>getArc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt;  * getArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the arc, if any, from node1 to node2. </p>
<p>If multiple arcs exist between the given two nodes, which is returned is unspecified. If no such arc exists, returns a null pointer. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000061">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a0690edaeae8d5256189ae2e8541788b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0690edaeae8d5256189ae2e8541788b5">&#9670;&nbsp;</a></span>getArcSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt;  * &gt; &amp; getArcSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all arcs in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000062">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a17cfc7f4d8c738fc6f51813f50be6400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cfc7f4d8c738fc6f51813f50be6400">&#9670;&nbsp;</a></span>getArcSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt;  * &gt; &amp; getArcSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all arcs that start at the specified node, indicated as a pointer to its node structure. </p>
<p>If the pointer passed is null or the given node is not found in the graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000063">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a31b9e2056ee2d66a7ea9feb02f016e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b9e2056ee2d66a7ea9feb02f016e8d">&#9670;&nbsp;</a></span>getArcSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt;  * &gt; &amp; getArcSet </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all arcs that start at the specified node. </p>
<p>If the given node is not found in the graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000064">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aad31ac511c91ccf23a19af68e7a9f316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad31ac511c91ccf23a19af68e7a9f316">&#9670;&nbsp;</a></span>getEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * getEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the structure representing the edge from v1 to v2 in the graph. </p>
<p>If either of the vertexes supplied is null or is not found in the graph, the function will return nullptr. If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.</p>
<p>Equivalent to getArc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>start vertex </td></tr>
    <tr><td class="paramname">v2</td><td>end vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge from v1 to v2, or nullptr if there is no such edge </dd></dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000017">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a57e156a4bae200f10f36fce5ec7fe504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e156a4bae200f10f36fce5ec7fe504">&#9670;&nbsp;</a></span>getEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * getEdge </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the structure representing the edge from v1 to v2 in the graph. </p>
<p>If either of the vertexes supplied is not found in the graph, the function will return nullptr. If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.</p>
<p>Equivalent to getArc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>start vertex </td></tr>
    <tr><td class="paramname">v2</td><td>end vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge from v1 to v2, or nullptr if there is no such edge </dd></dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000018">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a312cc70af3d52a9fbdd56629c1710e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312cc70af3d52a9fbdd56629c1710e48">&#9670;&nbsp;</a></span>getEdgeSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; &amp; getEdgeSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all edges in the graph. </p>
<p>Equivalent to getArcSet. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000019">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="abfe8d6cbb48312f7fbec0fd948330348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe8d6cbb48312f7fbec0fd948330348">&#9670;&nbsp;</a></span>getEdgeSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; &amp; getEdgeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all edges that start at the specified vertex. </p>
<p>If the vertex supplied is null or is not found in the graph, the function will return an empty set.</p>
<p>Equivalent to getArcSet. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000020">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a6deea7a4536dfd6346c62c0c05a141ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6deea7a4536dfd6346c62c0c05a141ed">&#9670;&nbsp;</a></span>getEdgeSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; &amp; getEdgeSet </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all edges that start at the specified vertex. </p>
<p>If the vertex supplied is not found in the graph, the function will return an empty set.</p>
<p>Equivalent to getArcSet. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000021">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ad8e645c23a9816fff136e0a5f7941669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e645c23a9816fff136e0a5f7941669">&#9670;&nbsp;</a></span>getInverseArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * getInverseArc </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the edge that is the opposite of the given edge; that is, if the specified edge e starts at v1 and ends at v2, will return the edge that starts at v2 and ends at v1, if such an edge exists in the graph. </p>
<p>If the edge supplied is nullptr, is not found in the graph, or has no inverse, the function will return nullptr.</p>
<p>If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.</p>
<p>Equivalent to getInverseEdge. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000022">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="ad5fd149800cd46aae497b05b46059b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fd149800cd46aae497b05b46059b63">&#9670;&nbsp;</a></span>getInverseArcSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt;  * &gt; getInverseArcSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of outbound arcs to the given node from other nodes. </p>
<p>In other words, getInverseArcSet(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000065">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a2cfe12e71ca594736a1e329461cff024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfe12e71ca594736a1e329461cff024">&#9670;&nbsp;</a></span>getInverseArcSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt;  * &gt; getInverseArcSet </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of outbound arcs to the given node from other nodes. </p>
<p>In other words, getInverseArcSet(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000066">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="ae81616e12d12f2dcfa295b4a3b48f960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81616e12d12f2dcfa295b4a3b48f960">&#9670;&nbsp;</a></span>getInverseEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EdgeGen&lt; V, E &gt; * getInverseEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the edge that is the opposite of the given edge; that is, if the specified edge e starts at v1 and ends at v2, will return the edge that starts at v2 and ends at v1, if such an edge exists in the graph. </p>
<p>If the edge supplied is nullptr, is not found in the graph, or has no inverse, the function will return nullptr.</p>
<p>If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.</p>
<p>Equivalent to getInverseArc. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000023">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a5db8788e3783e8ff16b19c06a5f2cf62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db8788e3783e8ff16b19c06a5f2cf62">&#9670;&nbsp;</a></span>getInverseEdgeSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; getInverseEdgeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all edges in the graph that end at the specified vertex. </p>
<p>If the vertex supplied is null or is not found in the graph, the function will return an empty set.</p>
<p>Equivalent to getInverseArcSet. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000024">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a7ef9596e6faf68669228bc69808e84bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef9596e6faf68669228bc69808e84bd">&#9670;&nbsp;</a></span>getInverseEdgeSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; EdgeGen&lt; V, E &gt; * &gt; getInverseEdgeSet </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all edges in the graph that end at the specified vertex. </p>
<p>If the vertex supplied is null or is not found in the graph, the function will return an empty set.</p>
<p>Equivalent to getInverseArcSet. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000025">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="aa9eceee00e824ea4852449fa3de61e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eceee00e824ea4852449fa3de61e82">&#9670;&nbsp;</a></span>getInverseNeighborNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getInverseNeighborNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of strings of names of nodes that are neighbors of the given node. </p>
<p>In other words, getInverseNeighborNames(n1) is the set of all strings n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000067">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="ac3dc36bc1eb0f249180cfe78bce6e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dc36bc1eb0f249180cfe78bce6e7a2">&#9670;&nbsp;</a></span>getInverseNeighborNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getInverseNeighborNames </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of strings of names of nodes that are neighbors of the given node. </p>
<p>In other words, getInverseNeighborNames(n1) is the set of all strings n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000068">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a80a5724c594b9bd0b6008c57b09af317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a5724c594b9bd0b6008c57b09af317">&#9670;&nbsp;</a></span>getInverseNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * &gt; getInverseNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getInverseNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000069">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a5294846b9cdd19394808e3736ec67004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5294846b9cdd19394808e3736ec67004">&#9670;&nbsp;</a></span>getInverseNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * &gt; getInverseNeighbors </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getInverseNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000070">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5cbd2bcb3918c4c64b1eb71c1a3a8">&#9670;&nbsp;</a></span>getNeighborNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getNeighborNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of node names that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all strings n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000071">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a6175b4d672266465dd34e070c7710b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6175b4d672266465dd34e070c7710b34">&#9670;&nbsp;</a></span>getNeighborNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getNeighborNames </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of node names that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all strings n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000072">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a0e49b167f0623a8ae76040c3e5eab3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e49b167f0623a8ae76040c3e5eab3fb">&#9670;&nbsp;</a></span>getNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * &gt; getNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000073">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a3a3720906c380f36b50530419330bfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3720906c380f36b50530419330bfe5">&#9670;&nbsp;</a></span>getNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * &gt; getNeighbors </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000074">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a81487976cf0e576047333c85463c33aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81487976cf0e576047333c85463c33aa">&#9670;&nbsp;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * getNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks up a node in the name table attached to the graph and returns a pointer to that node. </p>
<p>If no node with the specified name exists, returns <code>nullptr</code>. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000075">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a3c6f37932f377dd2bf4fec61343a916d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6f37932f377dd2bf4fec61343a916d">&#9670;&nbsp;</a></span>getNodeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getNodeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of the names of all nodes in the graph. </p>
<p>Similar to getNodeSet but returns a set of strings rather than a set of pointers to nodes. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000076">Big-Oh:</a></b></dt><dd>O(V log V) </dd></dl>

</div>
</div>
<a id="abd5552888f57aaa581099e8146c617c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5552888f57aaa581099e8146c617c9">&#9670;&nbsp;</a></span>getNodeSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  * &gt; &amp; getNodeSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all nodes in the graph. </p>
<p>These are direct pointers to the internal NodeType* structures in the graph, so any modifications you make to them will be reflected in the graph. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000077">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a4c0c055103d2adba54014d301ae7bd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0c055103d2adba54014d301ae7bd1c">&#9670;&nbsp;</a></span>getVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * getVertex </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a vertex in the graph by name and returns a pointer to its internal data structure. </p>
<p>If no vertex with the specified name exists, returns nullptr. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000026">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="ae1bca1f87888bd787f836bc064a9ff01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bca1f87888bd787f836bc064a9ff01">&#9670;&nbsp;</a></span>getVertexNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getVertexNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of the names of all vertexes in the graph. </p>
<p>The vertexes will be sorted by name in case-sensitive alphabetical order. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000027">Big-Oh:</a></b></dt><dd>O(V log V) </dd></dl>

</div>
</div>
<a id="aec896ef5b1fc6044fc71318d1369f6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec896ef5b1fc6044fc71318d1369f6f1">&#9670;&nbsp;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * &gt; &amp; getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all vertexes in the graph. </p>
<p>The vertexes will be sorted by name in case-sensitive alphabetical order. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000028">Big-Oh:</a></b></dt><dd>O(V log V) </dd></dl>

</div>
</div>
<a id="a54164ab847f3a5c7fe15d15ac95af443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54164ab847f3a5c7fe15d15ac95af443">&#9670;&nbsp;</a></span>isConnected() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>. </p>
<p>If any pointer passed is null, or if either node is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000078">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a3623b7decbedc522041c2c39d3b14421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3623b7decbedc522041c2c39d3b14421">&#9670;&nbsp;</a></span>isConnected() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnected </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>. </p>
<p>If either node is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000079">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the graph contains no vertexes. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000082">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ab160bb64995133f6feb351cb23b031fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab160bb64995133f6feb351cb23b031fb">&#9670;&nbsp;</a></span>isNeighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isNeighbor </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the graph contains an edge from v1 to v2. </p>
<p>If either of the vertexes supplied is not found in the graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000080">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a9e752628a118c4a06a538067c95bbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e752628a118c4a06a538067c95bbb28">&#9670;&nbsp;</a></span>isNeighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the graph contains an edge from v1 to v2. </p>
<p>If either of the vertexes supplied is null or is not found in the graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000081">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a5dd1afdb4e1c75fbe51976bf6f70c922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd1afdb4e1c75fbe51976bf6f70c922">&#9670;&nbsp;</a></span>nodeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes in the graph. </p>
<p>Equivalent to <a class="el" href="classGraph.html#af9593d4a5ff4274efaf429cb4f9e57cc" title="Returns the number of nodes in the graph. ">size()</a>. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000083">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aafd8d1cec3a4d6b8cdcb58016e4d093a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd8d1cec3a4d6b8cdcb58016e4d093a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The ==, != operators require that the ValueType has a == operator so that the elements can be tested for equality. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000094">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a1daf423faecc777e29a399812dc39ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1daf423faecc777e29a399812dc39ca2">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000095">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a352607f2b21dd87b3d2a3957bbf3da7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352607f2b21dd87b3d2a3957bbf3da7b">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000096">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a188f85939e3fe6ed2d411f622287f722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188f85939e3fe6ed2d411f622287f722">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The ==, != operators require that the ValueType has a == operator so that the elements can be tested for equality. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000093">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a8019cf2c98949fd509193cf26ba2ff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8019cf2c98949fd509193cf26ba2ff8a">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000097">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="ab1ca2af20f3b0251972b72295270212e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ca2af20f3b0251972b72295270212e">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000098">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a5e874dbb2f9f2c7f98ec74f00790eb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e874dbb2f9f2c7f98ec74f00790eb0e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * operator[] </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads <code>[]</code> to return vertex pointers by vertex name. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000038">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="ad91a5b6ebd034841cf4f4c410fb7ed1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91a5b6ebd034841cf4f4c410fb7ed1b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; * operator[] </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads <code>[]</code> to return vertex pointers by vertex name. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000039">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="af6370fb52d2dab4eb7795da22c33dd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6370fb52d2dab4eb7795da22c33dd02">&#9670;&nbsp;</a></span>removeArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an arc from v1 to v2 in the graph, specified by the names of its endpoints. </p>
<p>If more than one arc connects the specified endpoints, all of them are removed. If no arc connects the given endpoints, or the given arc is not found, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000084">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="ae0c9f44b20b49ffae9fecc0a4f156ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c9f44b20b49ffae9fecc0a4f156ac1">&#9670;&nbsp;</a></span>removeArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an arc from v1 to v2 in the graph, specified by the node pointers at its endpoints. </p>
<p>If more than one arc connects the specified endpoints, all of them are removed. If no arc connects the given endpoints, or the given arc is not found, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000085">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a9d6580d1b0228fe6c1a02dfe70de1abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6580d1b0228fe6c1a02dfe70de1abf">&#9670;&nbsp;</a></span>removeArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeArc </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given arc from the graph, specified as an arc pointer. </p>
<p>If more than one arc connects the specified endpoints, all of them are removed. If no arc connects the given endpoints, or the given arc is not found, the call has no effect.</p>
<p>Memory management: Our code will delete/free the ArcType* object when done with it. You do not need to (and should not) free it yourself. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000086">Big-Oh:</a></b></dt><dd>O(log E + log V) </dd></dl>

</div>
</div>
<a id="adfee7a20d0c13cc515b3b7e951d8baf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfee7a20d0c13cc515b3b7e951d8baf2">&#9670;&nbsp;</a></span>removeEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeEdge </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the edge from v1 to v2 from the graph. </p>
<p>If more than one edge connects the specified endpoints, all of them are removed. If either of the vertexes supplied is not found in the graph, calling this function will have no effect on the graph. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000029">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a8b1003fbe63fab20173526459fff4139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1003fbe63fab20173526459fff4139">&#9670;&nbsp;</a></span>removeEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the edge from v1 to v2 from the graph. </p>
<p>If more than one edge connects the specified endpoints, all of them are removed. If either of the vertexes supplied is null or not found in the graph, calling this function will have no effect on the graph. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000030">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a2c6bb1e8e2c18b7376504692f7baae62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6bb1e8e2c18b7376504692f7baae62">&#9670;&nbsp;</a></span>removeEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given edge from the graph. </p>
<p>If the edge supplied is not found in the graph, calling this function will have no effect on the graph. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000031">Big-Oh:</a></b></dt><dd>O(log E + log V) </dd></dl>

</div>
</div>
<a id="a2d5f7ee89176144ed4c5c6b08a233aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5f7ee89176144ed4c5c6b08a233aa6">&#9670;&nbsp;</a></span>removeNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the node with the given name from the graph. </p>
<p>Removing a node also removes all arcs that contain that node. If a node name is passed that is not part of the graph, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000087">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a2dfe63019975561914e0ed79551de108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfe63019975561914e0ed79551de108">&#9670;&nbsp;</a></span>removeNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a node from the graph, specified as a pointer value. </p>
<p>Removing a node also removes all arcs that contain that node. If a node or name is passed that is null or is not part of the graph, the call has no effect.</p>
<p>Memory management: Our code will delete/free the NodeType* object when done with it. You do not need to (and should not) free it yourself. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000088">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="aaa33b4c05ee490d241ba5542420b985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa33b4c05ee490d241ba5542420b985b">&#9670;&nbsp;</a></span>removeVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeVertex </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given vertex from the graph. </p>
<p>If the vertex is not found in the graph, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000032">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a9eac2d17b5e8074dace019020d078acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eac2d17b5e8074dace019020d078acb">&#9670;&nbsp;</a></span>removeVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given vertex from the graph. </p>
<p>If the vertex is null or is not found in the graph, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000033">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a4314b3b6bda0755a87e49070edd17c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4314b3b6bda0755a87e49070edd17c3d">&#9670;&nbsp;</a></span>scanArcData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scanArcData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the data for an arc from the scanner. </p>
<p>The <code>forward</code> argument points to the arc in the forward direction. If the arc is undirected, <code>backward</code> points to the reverse arc; for directed arcs, the <code>backward</code> pointer is <code>nullptr</code>.</p>
<p>The default implementation of this method is empty. Clients that want to initialize other fields in the arc must override this method so that it initializes one or both arc, as appropriate. </p>

<p>Reimplemented from <a class="el" href="classGraph.html#ac73c985ef66569e5f6df9c315cab466b">Graph&lt; VertexGen&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt;</a>.</p>

</div>
</div>
<a id="a1c4e1a05a40013ce4e4bb539d05b9937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4e1a05a40013ce4e4bb539d05b9937">&#9670;&nbsp;</a></span>scanGraphEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool scanGraphEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;&#160;</td>
          <td class="paramname"><em>scanner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method reads one "entry" for the graph, which is either a node description or an arc description. </p>
<p>The <code>scanGraphEntry</code> method returns <code>true</code> if it reads an entry, and <code>false</code> at the end of file or at text that cannot be recognized as a graph entry.</p>
<p>Node entries consist of the name of a node (which may be quoted if it contains special characters), optionally followed by data for the node. Arc descriptions have one of the following forms:</p>
<pre>
n1 -&gt; n2
n1 - n2
</pre><p>either of which can be followed by data for the arc. The first form creates a single directed arc; the second creates two arcs, one in each direction.</p>
<p>Clients who want to read node or arc data must override the empty versions of <code>scanNodeData</code> and <code>scanArcData</code> included in this interface. </p>

</div>
</div>
<a id="a0fc2ca3535b7bff7759aa0c1d35ff08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc2ca3535b7bff7759aa0c1d35ff08b">&#9670;&nbsp;</a></span>scanNodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void scanNodeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the data for the specified node from the scanner. </p>
<p>The default implementation of this method is empty. Clients that want to initialize other fields in the node from the token stream must override this method. </p>

</div>
</div>
<a id="af9593d4a5ff4274efaf429cb4f9e57cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9593d4a5ff4274efaf429cb4f9e57cc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes in the graph. </p>
<p>Equivalent to nodeCount. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000089">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a66498d3675a5bc08fa30a032d41764f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66498d3675a5bc08fa30a032d41764f7">&#9670;&nbsp;</a></span>toMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMap.html">Map</a>&lt; string, <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; &gt; toMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classMap.html">Map</a> representing an adjacency list equivalent to this graph. </p>
<p>Each vertex's name is a key in the map, and its neighboring vertexes' names are stored in a Set as the value associated with that key. It should be noted that this member does not preserve the weights of the edges between the neighboring vertexes, so it is not ideal for use with weighted graphs. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000036">Big-Oh:</a></b></dt><dd>O(V + E) </dd></dl>

</div>
</div>
<a id="a1fe5121d6528fdea3f243321b3fa3a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5121d6528fdea3f243321b3fa3a49">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the graph to a printable string representation. </p>
<dl class="section return"><dt>Returns</dt><dd>a string such as <code>"{A, B, C, D, A - B, B - D, C - D}"</code>. </dd></dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000090">Big-Oh:</a></b></dt><dd>O(V + E) </dd></dl>

</div>
</div>
<a id="a68eb4830a4800ed7704895c16a8982be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eb4830a4800ed7704895c16a8982be">&#9670;&nbsp;</a></span>vertexCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertexes in the graph. </p>
<p>Equivalent to size. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000037">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ae7be688f4ddbd7da8eb2a8c7eef8901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7be688f4ddbd7da8eb2a8c7eef8901c">&#9670;&nbsp;</a></span>writeArcData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeArcData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeGen&lt; V, E &gt; *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the data for the arc to the output stream. </p>
<p>The default implementation of this method is empty. Clients that want to store other fields from the arc must override this method so that it writes that data in a form that scanArcData can read. </p>

<p>Reimplemented from <a class="el" href="classGraph.html#ac9ab61a83ff4792f63e9e110b534cdfd">Graph&lt; VertexGen&lt; V, E &gt;, EdgeGen&lt; V, E &gt; &gt;</a>.</p>

</div>
</div>
<a id="ac0db5231476c8cb10655d58ebc108b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0db5231476c8cb10655d58ebc108b78">&#9670;&nbsp;</a></span>writeNodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void writeNodeData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertexGen.html">VertexGen</a>&lt; V, E &gt;  *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the data for the node to the output stream. </p>
<p>The default implementation of this method is empty. Clients that want to store other fields from the node must override this method so that it writes that data in a form that scanNodeData can read. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
