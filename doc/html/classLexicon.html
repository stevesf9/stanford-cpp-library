<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StanfordCPPLib: Lexicon Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StanfordCPPLib
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classLexicon-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Lexicon Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><br />
 This class is used to represent a <b><em>lexicon,</em></b> or word list.  
 <a href="classLexicon.html#details">More...</a></p>

<p><code>#include "<a class="el" href="lexicon_8h_source.html">lexicon.h</a>"</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac38cafae91a89528e71f257cbad724fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ac38cafae91a89528e71f257cbad724fd">Lexicon</a>()</td></tr>
<tr class="separator:ac38cafae91a89528e71f257cbad724fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60e4bcfef0337c5133d3bedcccd06f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a6e60e4bcfef0337c5133d3bedcccd06f">Lexicon</a>(std::istream &amp;input)</td></tr>
<tr class="separator:a6e60e4bcfef0337c5133d3bedcccd06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a064a38897e1e4ce9b755a238723f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a64a064a38897e1e4ce9b755a238723f4">Lexicon</a>(string filename)</td></tr>
<tr class="separator:a64a064a38897e1e4ce9b755a238723f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acc6dfba69bc35cba25ee02ac91c4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a0acc6dfba69bc35cba25ee02ac91c4e5">Lexicon</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="separator:a0acc6dfba69bc35cba25ee02ac91c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd310b995d41180f2f29bd68bec7d290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#acd310b995d41180f2f29bd68bec7d290">Lexicon</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;src)</td></tr>
<tr class="separator:acd310b995d41180f2f29bd68bec7d290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d71fdc56ec42614e240463e6724969e"><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a9d71fdc56ec42614e240463e6724969e">~Lexicon</a>()</td></tr>
<tr class="separator:a9d71fdc56ec42614e240463e6724969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae678e727fb107637268e8f00cd759889"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ae678e727fb107637268e8f00cd759889">add</a>(string word)</td></tr>
<tr class="memdesc:ae678e727fb107637268e8f00cd759889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified word to the lexicon, if not already present.  <a href="#ae678e727fb107637268e8f00cd759889">More...</a><br /></td></tr>
<tr class="separator:ae678e727fb107637268e8f00cd759889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d62d8dcb351ae40c8a2220a9871348b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a9d62d8dcb351ae40c8a2220a9871348b">addAll</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex)</td></tr>
<tr class="memdesc:a9d62d8dcb351ae40c8a2220a9871348b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all elements of the given other lexicon to this lexicon.  <a href="#a9d62d8dcb351ae40c8a2220a9871348b">More...</a><br /></td></tr>
<tr class="separator:a9d62d8dcb351ae40c8a2220a9871348b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554e59039648403990042d16710855e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a554e59039648403990042d16710855e0">addAll</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="memdesc:a554e59039648403990042d16710855e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all elements of the given initializer list to this lexicon.  <a href="#a554e59039648403990042d16710855e0">More...</a><br /></td></tr>
<tr class="separator:a554e59039648403990042d16710855e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215fcead487aace2e89b04863e326ba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a215fcead487aace2e89b04863e326ba6">addWordsFromFile</a>(std::istream &amp;input)</td></tr>
<tr class="memdesc:a215fcead487aace2e89b04863e326ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the given input stream and adds all of its words to the lexicon.  <a href="#a215fcead487aace2e89b04863e326ba6">More...</a><br /></td></tr>
<tr class="separator:a215fcead487aace2e89b04863e326ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3891deaa85aee9a52b6ca258d1514716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a3891deaa85aee9a52b6ca258d1514716">addWordsFromFile</a>(string filename)</td></tr>
<tr class="memdesc:a3891deaa85aee9a52b6ca258d1514716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the file and adds all of its words to the lexicon.  <a href="#a3891deaa85aee9a52b6ca258d1514716">More...</a><br /></td></tr>
<tr class="separator:a3891deaa85aee9a52b6ca258d1514716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324ff6b85a0d392036efefc95b5d5e83"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a324ff6b85a0d392036efefc95b5d5e83">back</a>() const</td></tr>
<tr class="memdesc:a324ff6b85a0d392036efefc95b5d5e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last value in the lexicon in alphabetical order.  <a href="#a324ff6b85a0d392036efefc95b5d5e83">More...</a><br /></td></tr>
<tr class="separator:a324ff6b85a0d392036efefc95b5d5e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c62c15c8ed609e7e5e9518cf5f5c712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a0c62c15c8ed609e7e5e9518cf5f5c712">begin</a>() const</td></tr>
<tr class="memdesc:a0c62c15c8ed609e7e5e9518cf5f5c712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator positioned at the first word in the lexicon.  <a href="#a0c62c15c8ed609e7e5e9518cf5f5c712">More...</a><br /></td></tr>
<tr class="separator:a0c62c15c8ed609e7e5e9518cf5f5c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all words from the lexicon.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479b1bac4a3c243907c80e5c6f9b05d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a479b1bac4a3c243907c80e5c6f9b05d5">contains</a>(string word) const</td></tr>
<tr class="memdesc:a479b1bac4a3c243907c80e5c6f9b05d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>word</code> is contained in the lexicon.  <a href="#a479b1bac4a3c243907c80e5c6f9b05d5">More...</a><br /></td></tr>
<tr class="separator:a479b1bac4a3c243907c80e5c6f9b05d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc56f4fc1106ca74a59fceb9d68b3e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a9cc56f4fc1106ca74a59fceb9d68b3e9">containsAll</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;set2) const</td></tr>
<tr class="memdesc:a9cc56f4fc1106ca74a59fceb9d68b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if every value from the given other lexicon is also found in this lexicon.  <a href="#a9cc56f4fc1106ca74a59fceb9d68b3e9">More...</a><br /></td></tr>
<tr class="separator:a9cc56f4fc1106ca74a59fceb9d68b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3934298595e72e6540e5f81d47ab763a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a3934298595e72e6540e5f81d47ab763a">containsAll</a>(std::initializer_list&lt; string &gt; list) const</td></tr>
<tr class="memdesc:a3934298595e72e6540e5f81d47ab763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if every value from the given initializer list is also found in this lexicon.  <a href="#a3934298595e72e6540e5f81d47ab763a">More...</a><br /></td></tr>
<tr class="separator:a3934298595e72e6540e5f81d47ab763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e0b0b6f72ba6b88b56bd074b1dc32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a0b8e0b0b6f72ba6b88b56bd074b1dc32">containsPrefix</a>(string prefix) const</td></tr>
<tr class="memdesc:a0b8e0b0b6f72ba6b88b56bd074b1dc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any words in the lexicon begin with <code>prefix</code>.  <a href="#a0b8e0b0b6f72ba6b88b56bd074b1dc32">More...</a><br /></td></tr>
<tr class="separator:a0b8e0b0b6f72ba6b88b56bd074b1dc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b688a51bd0cf6fb5bc2cba292209a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a68b688a51bd0cf6fb5bc2cba292209a8">end</a>() const</td></tr>
<tr class="memdesc:a68b688a51bd0cf6fb5bc2cba292209a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator positioned at the last word in the lexicon.  <a href="#a68b688a51bd0cf6fb5bc2cba292209a8">More...</a><br /></td></tr>
<tr class="separator:a68b688a51bd0cf6fb5bc2cba292209a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd6de171cb80bc7e2b48d53bd1e9276"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a7dd6de171cb80bc7e2b48d53bd1e9276">equals</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a7dd6de171cb80bc7e2b48d53bd1e9276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two lexicons for equality.  <a href="#a7dd6de171cb80bc7e2b48d53bd1e9276">More...</a><br /></td></tr>
<tr class="separator:a7dd6de171cb80bc7e2b48d53bd1e9276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba89eab0637bde14f9ded33e9e9c6aa5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#aba89eab0637bde14f9ded33e9e9c6aa5">first</a>() const</td></tr>
<tr class="memdesc:aba89eab0637bde14f9ded33e9e9c6aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first value in the lexicon in alphabetical order.  <a href="#aba89eab0637bde14f9ded33e9e9c6aa5">More...</a><br /></td></tr>
<tr class="separator:aba89eab0637bde14f9ded33e9e9c6aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054217ec9f3229ceedee9d7bde075587"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a054217ec9f3229ceedee9d7bde075587">front</a>() const</td></tr>
<tr class="memdesc:a054217ec9f3229ceedee9d7bde075587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first value in the lexicon in alphabetical order.  <a href="#a054217ec9f3229ceedee9d7bde075587">More...</a><br /></td></tr>
<tr class="separator:a054217ec9f3229ceedee9d7bde075587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a017af6eb755b5c83e70f61e2bda2c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a1a017af6eb755b5c83e70f61e2bda2c7">insert</a>(string word)</td></tr>
<tr class="memdesc:a1a017af6eb755b5c83e70f61e2bda2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to this lexicon, if it was not already there.  <a href="#a1a017af6eb755b5c83e70f61e2bda2c7">More...</a><br /></td></tr>
<tr class="separator:a1a017af6eb755b5c83e70f61e2bda2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a>() const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the lexicon contains no words.  <a href="#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c118f41dad8941a624c3ff479987e3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a6c118f41dad8941a624c3ff479987e3d">isSubsetOf</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a6c118f41dad8941a624c3ff479987e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether every word of this lexicon is contained in the given set.  <a href="#a6c118f41dad8941a624c3ff479987e3d">More...</a><br /></td></tr>
<tr class="separator:a6c118f41dad8941a624c3ff479987e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0f1241b53bcf0b31103b79cb01b87d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a2a0f1241b53bcf0b31103b79cb01b87d">isSubsetOf</a>(std::initializer_list&lt; string &gt; list) const</td></tr>
<tr class="memdesc:a2a0f1241b53bcf0b31103b79cb01b87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether every word of this lexicon is contained in the given initializer list.  <a href="#a2a0f1241b53bcf0b31103b79cb01b87d">More...</a><br /></td></tr>
<tr class="separator:a2a0f1241b53bcf0b31103b79cb01b87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a4796a72905df1e33f4b100cb91f32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ad6a4796a72905df1e33f4b100cb91f32">isSupersetOf</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:ad6a4796a72905df1e33f4b100cb91f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether every word of the given lexicon is contained in this lexicon.  <a href="#ad6a4796a72905df1e33f4b100cb91f32">More...</a><br /></td></tr>
<tr class="separator:ad6a4796a72905df1e33f4b100cb91f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217cbc1e6ba9f694645608c8a17c1943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a217cbc1e6ba9f694645608c8a17c1943">isSupersetOf</a>(std::initializer_list&lt; string &gt; list) const</td></tr>
<tr class="memdesc:a217cbc1e6ba9f694645608c8a17c1943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether every word of the given list is contained in this lexicon.  <a href="#a217cbc1e6ba9f694645608c8a17c1943">More...</a><br /></td></tr>
<tr class="separator:a217cbc1e6ba9f694645608c8a17c1943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4e14ffb291ba4d5475b9b66d2a12c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a2e4e14ffb291ba4d5475b9b66d2a12c8">mapAll</a>(void(*fn)(string)) const</td></tr>
<tr class="memdesc:a2e4e14ffb291ba4d5475b9b66d2a12c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function on each word in the lexicon.  <a href="#a2e4e14ffb291ba4d5475b9b66d2a12c8">More...</a><br /></td></tr>
<tr class="separator:a2e4e14ffb291ba4d5475b9b66d2a12c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab83598d63d43b15cf018fa020e1ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#abab83598d63d43b15cf018fa020e1ddf">mapAll</a>(void(*fn)(string )) const</td></tr>
<tr class="memdesc:abab83598d63d43b15cf018fa020e1ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function on each word in the lexicon.  <a href="#abab83598d63d43b15cf018fa020e1ddf">More...</a><br /></td></tr>
<tr class="separator:abab83598d63d43b15cf018fa020e1ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc32c1e45704cfae41daf8adb4e66dc"><td class="memTemplParams" colspan="2">template&lt;typename FunctorType &gt; </td></tr>
<tr class="memitem:a8dc32c1e45704cfae41daf8adb4e66dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLexicon.html#a8dc32c1e45704cfae41daf8adb4e66dc">mapAll</a>(FunctorType fn) const</td></tr>
<tr class="memdesc:a8dc32c1e45704cfae41daf8adb4e66dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function on each word in the lexicon.  <a href="#a8dc32c1e45704cfae41daf8adb4e66dc">More...</a><br /></td></tr>
<tr class="separator:a8dc32c1e45704cfae41daf8adb4e66dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42d8a30a8c4b2d33a6be3b12258e152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#af42d8a30a8c4b2d33a6be3b12258e152">operator!=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:af42d8a30a8c4b2d33a6be3b12258e152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two lexicons do not have the same elements.  <a href="#af42d8a30a8c4b2d33a6be3b12258e152">More...</a><br /></td></tr>
<tr class="separator:af42d8a30a8c4b2d33a6be3b12258e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62286f0f5d7c1229b3003b855bf54ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a62286f0f5d7c1229b3003b855bf54ba3">operator*</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a62286f0f5d7c1229b3003b855bf54ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two lexicons, which is the set of all words that appear in both.  <a href="#a62286f0f5d7c1229b3003b855bf54ba3">More...</a><br /></td></tr>
<tr class="separator:a62286f0f5d7c1229b3003b855bf54ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da3a8f0f6332bccefe7b2cb48d8a8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a5da3a8f0f6332bccefe7b2cb48d8a8d6">operator*</a>(std::initializer_list&lt; string &gt; list) const</td></tr>
<tr class="memdesc:a5da3a8f0f6332bccefe7b2cb48d8a8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of this lexicons and the given list, which is the set of all words that appear in both.  <a href="#a5da3a8f0f6332bccefe7b2cb48d8a8d6">More...</a><br /></td></tr>
<tr class="separator:a5da3a8f0f6332bccefe7b2cb48d8a8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81e3c0d6a5637202849784ef00b9cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ab81e3c0d6a5637202849784ef00b9cd5">operator*=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2)</td></tr>
<tr class="memdesc:ab81e3c0d6a5637202849784ef00b9cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any elements from this lexicon that are not present in <code>lex2</code>.  <a href="#ab81e3c0d6a5637202849784ef00b9cd5">More...</a><br /></td></tr>
<tr class="separator:ab81e3c0d6a5637202849784ef00b9cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ada3cb64d9f074114ce895c67be781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a79ada3cb64d9f074114ce895c67be781">operator*=</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="memdesc:a79ada3cb64d9f074114ce895c67be781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any elements from this lexicon that are not present in the given initializer list.  <a href="#a79ada3cb64d9f074114ce895c67be781">More...</a><br /></td></tr>
<tr class="separator:a79ada3cb64d9f074114ce895c67be781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc41a903b549304f3b70e48fd2e52e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#acfc41a903b549304f3b70e48fd2e52e4">operator+</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:acfc41a903b549304f3b70e48fd2e52e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of lexicons <code>lex1</code> and <code>lex2</code>, which is the set of words that appear in at least one of the two.  <a href="#acfc41a903b549304f3b70e48fd2e52e4">More...</a><br /></td></tr>
<tr class="separator:acfc41a903b549304f3b70e48fd2e52e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4436a915b6de75438364ed061e0e9491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a4436a915b6de75438364ed061e0e9491">operator+</a>(std::initializer_list&lt; string &gt; list) const</td></tr>
<tr class="memdesc:a4436a915b6de75438364ed061e0e9491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of this lexicon and the words in the given list, which is the set of words that appear in at least one of the two.  <a href="#a4436a915b6de75438364ed061e0e9491">More...</a><br /></td></tr>
<tr class="separator:a4436a915b6de75438364ed061e0e9491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44774af5311cf2c8fd054ecf8ff8e76b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a44774af5311cf2c8fd054ecf8ff8e76b">operator+</a>(string word) const</td></tr>
<tr class="memdesc:a44774af5311cf2c8fd054ecf8ff8e76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of this lexicon and the given word.  <a href="#a44774af5311cf2c8fd054ecf8ff8e76b">More...</a><br /></td></tr>
<tr class="separator:a44774af5311cf2c8fd054ecf8ff8e76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70421c28007f127e7c4b24666ecc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#afa70421c28007f127e7c4b24666ecc3a">operator+=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2)</td></tr>
<tr class="memdesc:afa70421c28007f127e7c4b24666ecc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all of the words from the given lexicon to this lexicon.  <a href="#afa70421c28007f127e7c4b24666ecc3a">More...</a><br /></td></tr>
<tr class="separator:afa70421c28007f127e7c4b24666ecc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3080ac30a072160945adc5f860ca1785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a3080ac30a072160945adc5f860ca1785">operator+=</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="memdesc:a3080ac30a072160945adc5f860ca1785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all of the words from the given list to this lexicon.  <a href="#a3080ac30a072160945adc5f860ca1785">More...</a><br /></td></tr>
<tr class="separator:a3080ac30a072160945adc5f860ca1785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051f30ebfa7b8fbb7ea1dc5af23d3004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a051f30ebfa7b8fbb7ea1dc5af23d3004">operator+=</a>(string word)</td></tr>
<tr class="memdesc:a051f30ebfa7b8fbb7ea1dc5af23d3004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified word to this lexicon.  <a href="#a051f30ebfa7b8fbb7ea1dc5af23d3004">More...</a><br /></td></tr>
<tr class="separator:a051f30ebfa7b8fbb7ea1dc5af23d3004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f32eb2f65c3c3968193cfd72bdfd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a75f32eb2f65c3c3968193cfd72bdfd1a">operator,</a>(string word)</td></tr>
<tr class="separator:a75f32eb2f65c3c3968193cfd72bdfd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487624601a6357e1b6d64053f9ebb5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a487624601a6357e1b6d64053f9ebb5e2">operator-</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a487624601a6357e1b6d64053f9ebb5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference of two lexicons, which is all of the words that appear in <code>lex1</code> but not <code>lex2</code>.  <a href="#a487624601a6357e1b6d64053f9ebb5e2">More...</a><br /></td></tr>
<tr class="separator:a487624601a6357e1b6d64053f9ebb5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd415d08567bfae9eae12afe2169cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a0cd415d08567bfae9eae12afe2169cb5">operator-</a>(std::initializer_list&lt; string &gt; list) const</td></tr>
<tr class="memdesc:a0cd415d08567bfae9eae12afe2169cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference of two lexicons, which is all of the words that appear in this lexicon but not in the given initializer list.  <a href="#a0cd415d08567bfae9eae12afe2169cb5">More...</a><br /></td></tr>
<tr class="separator:a0cd415d08567bfae9eae12afe2169cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c8fea4b958b02ea5ee55d5509db8e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a14c8fea4b958b02ea5ee55d5509db8e6">operator-</a>(string word) const</td></tr>
<tr class="memdesc:a14c8fea4b958b02ea5ee55d5509db8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new lexicon formed by removing the given word from this lexicon.  <a href="#a14c8fea4b958b02ea5ee55d5509db8e6">More...</a><br /></td></tr>
<tr class="separator:a14c8fea4b958b02ea5ee55d5509db8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51e54102d6257c1a0a48c99ad2520f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ac51e54102d6257c1a0a48c99ad2520f6">operator-=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2)</td></tr>
<tr class="memdesc:ac51e54102d6257c1a0a48c99ad2520f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements in the given lexicon from this lexicon.  <a href="#ac51e54102d6257c1a0a48c99ad2520f6">More...</a><br /></td></tr>
<tr class="separator:ac51e54102d6257c1a0a48c99ad2520f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3ac9124341c069a604d760190789b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a1b3ac9124341c069a604d760190789b1">operator-=</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="memdesc:a1b3ac9124341c069a604d760190789b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements in the given list from this lexicon.  <a href="#a1b3ac9124341c069a604d760190789b1">More...</a><br /></td></tr>
<tr class="separator:a1b3ac9124341c069a604d760190789b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acb1cafdecdbf77b1d62f2372a6d244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a4acb1cafdecdbf77b1d62f2372a6d244">operator-=</a>(string value)</td></tr>
<tr class="memdesc:a4acb1cafdecdbf77b1d62f2372a6d244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given word from this lexicon.  <a href="#a4acb1cafdecdbf77b1d62f2372a6d244">More...</a><br /></td></tr>
<tr class="separator:a4acb1cafdecdbf77b1d62f2372a6d244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad808851ca0fffc8b60fd0b69ad097bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#aad808851ca0fffc8b60fd0b69ad097bd">operator&lt;</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:aad808851ca0fffc8b60fd0b69ad097bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two lexicons.  <a href="#aad808851ca0fffc8b60fd0b69ad097bd">More...</a><br /></td></tr>
<tr class="separator:aad808851ca0fffc8b60fd0b69ad097bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236ec3f5ec721fb4ca4551bf49123eac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a236ec3f5ec721fb4ca4551bf49123eac">operator&lt;=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a236ec3f5ec721fb4ca4551bf49123eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two lexicons.  <a href="#a236ec3f5ec721fb4ca4551bf49123eac">More...</a><br /></td></tr>
<tr class="separator:a236ec3f5ec721fb4ca4551bf49123eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9766b3af1f48ed51a1bcf037e08de43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#ab9766b3af1f48ed51a1bcf037e08de43">operator=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;src)</td></tr>
<tr class="separator:ab9766b3af1f48ed51a1bcf037e08de43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcab616682564bf55eb0b096a35219d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a4fcab616682564bf55eb0b096a35219d">operator==</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a4fcab616682564bf55eb0b096a35219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if two lexicons have the same elements.  <a href="#a4fcab616682564bf55eb0b096a35219d">More...</a><br /></td></tr>
<tr class="separator:a4fcab616682564bf55eb0b096a35219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04139ff41f8d25adbf5958ff2b01b068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a04139ff41f8d25adbf5958ff2b01b068">operator&gt;</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a04139ff41f8d25adbf5958ff2b01b068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two lexicons.  <a href="#a04139ff41f8d25adbf5958ff2b01b068">More...</a><br /></td></tr>
<tr class="separator:a04139ff41f8d25adbf5958ff2b01b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b7f6593b8b859858cf21ffbc9e5ab1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a05b7f6593b8b859858cf21ffbc9e5ab1">operator&gt;=</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex2) const</td></tr>
<tr class="memdesc:a05b7f6593b8b859858cf21ffbc9e5ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two lexicons.  <a href="#a05b7f6593b8b859858cf21ffbc9e5ab1">More...</a><br /></td></tr>
<tr class="separator:a05b7f6593b8b859858cf21ffbc9e5ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc6169b054fb3bbc4d72694e1a5834e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#affc6169b054fb3bbc4d72694e1a5834e">remove</a>(string word)</td></tr>
<tr class="memdesc:affc6169b054fb3bbc4d72694e1a5834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified word from the lexicon, if it was present.  <a href="#affc6169b054fb3bbc4d72694e1a5834e">More...</a><br /></td></tr>
<tr class="separator:affc6169b054fb3bbc4d72694e1a5834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606a7338945745d8ac9ce21f456f08d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a606a7338945745d8ac9ce21f456f08d9">removeAll</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex)</td></tr>
<tr class="memdesc:a606a7338945745d8ac9ce21f456f08d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements of the given other lexicon from this lexicon.  <a href="#a606a7338945745d8ac9ce21f456f08d9">More...</a><br /></td></tr>
<tr class="separator:a606a7338945745d8ac9ce21f456f08d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef0b8a849b2d33d83bc9689c4c4d090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a8ef0b8a849b2d33d83bc9689c4c4d090">removeAll</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="memdesc:a8ef0b8a849b2d33d83bc9689c4c4d090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements of the given other list from this lexicon.  <a href="#a8ef0b8a849b2d33d83bc9689c4c4d090">More...</a><br /></td></tr>
<tr class="separator:a8ef0b8a849b2d33d83bc9689c4c4d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998af18a2f0af7d18ce689acee75ca59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a998af18a2f0af7d18ce689acee75ca59">removePrefix</a>(string prefix)</td></tr>
<tr class="memdesc:a998af18a2f0af7d18ce689acee75ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all words from the lexicon that begin with the given prefix.  <a href="#a998af18a2f0af7d18ce689acee75ca59">More...</a><br /></td></tr>
<tr class="separator:a998af18a2f0af7d18ce689acee75ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38501eec95ff302cb83dae17ab478b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a38501eec95ff302cb83dae17ab478b81">retainAll</a>(const <a class="el" href="classLexicon.html">Lexicon</a> &amp;lex)</td></tr>
<tr class="memdesc:a38501eec95ff302cb83dae17ab478b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from this lexicon that are not contained in the given other lexicon.  <a href="#a38501eec95ff302cb83dae17ab478b81">More...</a><br /></td></tr>
<tr class="separator:a38501eec95ff302cb83dae17ab478b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b175aadba16c14093da01963914b33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a17b175aadba16c14093da01963914b33">retainAll</a>(std::initializer_list&lt; string &gt; list)</td></tr>
<tr class="memdesc:a17b175aadba16c14093da01963914b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from this lexicon that are not contained in the given initializer list.  <a href="#a17b175aadba16c14093da01963914b33">More...</a><br /></td></tr>
<tr class="separator:a17b175aadba16c14093da01963914b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#af9593d4a5ff4274efaf429cb4f9e57cc">size</a>() const</td></tr>
<tr class="memdesc:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of words contained in the lexicon.  <a href="#af9593d4a5ff4274efaf429cb4f9e57cc">More...</a><br /></td></tr>
<tr class="separator:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicon.html#a1fe5121d6528fdea3f243321b3fa3a49">toString</a>() const</td></tr>
<tr class="memdesc:a1fe5121d6528fdea3f243321b3fa3a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the lexicon to a printable string representation such as <code>{"a", "b", "c"}</code>.  <a href="#a1fe5121d6528fdea3f243321b3fa3a49">More...</a><br /></td></tr>
<tr class="separator:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><br />
 This class is used to represent a <b><em>lexicon,</em></b> or word list. </p>
<p>The main difference between a lexicon and a dictionary is that a lexicon does not provide any mechanism for storing definitions; the lexicon contains only words, with no associated information. It is therefore similar to a set of strings, but with a more space-efficient internal representation. The <code><a class="el" href="classLexicon.html" title="  This class is used to represent a lexicon, or word list. ">Lexicon</a></code> class supports efficient lookup operations for words and prefixes.</p>
<p>As an example of the use of the <code><a class="el" href="classLexicon.html" title="  This class is used to represent a lexicon, or word list. ">Lexicon</a></code> class, the following program lists all the two-letter words in the lexicon stored in <code>EnglishWords.dat</code>:</p>
<pre>
     int main() {
        <a class="el" href="classLexicon.html" title="  This class is used to represent a lexicon, or word list. ">Lexicon</a> english("EnglishWords.dat");
        for (string word : english) {
           if (word.length() == 2) {
              cout &lt;&lt; word &lt;&lt; endl;
           }
        }
        return 0;
     }
*</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac38cafae91a89528e71f257cbad724fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38cafae91a89528e71f257cbad724fd">&#9670;&nbsp;</a></span>Lexicon() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e60e4bcfef0337c5133d3bedcccd06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e60e4bcfef0337c5133d3bedcccd06f">&#9670;&nbsp;</a></span>Lexicon() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64a064a38897e1e4ce9b755a238723f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a064a38897e1e4ce9b755a238723f4">&#9670;&nbsp;</a></span>Lexicon() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0acc6dfba69bc35cba25ee02ac91c4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acc6dfba69bc35cba25ee02ac91c4e5">&#9670;&nbsp;</a></span>Lexicon() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d71fdc56ec42614e240463e6724969e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d71fdc56ec42614e240463e6724969e">&#9670;&nbsp;</a></span>~Lexicon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classLexicon.html">Lexicon</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd310b995d41180f2f29bd68bec7d290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd310b995d41180f2f29bd68bec7d290">&#9670;&nbsp;</a></span>Lexicon() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae678e727fb107637268e8f00cd759889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae678e727fb107637268e8f00cd759889">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool add </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified word to the lexicon, if not already present. </p>
<p>The word is converted to lowercase before adding it to the lexicon. If the word contains any non-alphabetic characters (including whitespace), it will not be added. The empty string cannot be added to a lexicon. Returns true if the word was added successfully to the lexicon. </p>

</div>
</div>
<a id="a9d62d8dcb351ae40c8a2220a9871348b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d62d8dcb351ae40c8a2220a9871348b">&#9670;&nbsp;</a></span>addAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; addAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all elements of the given other lexicon to this lexicon. </p>
<p>Returns a reference to this lexicon. Identical in behavior to the += operator. </p>

</div>
</div>
<a id="a554e59039648403990042d16710855e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554e59039648403990042d16710855e0">&#9670;&nbsp;</a></span>addAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; addAll </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all elements of the given initializer list to this lexicon. </p>
<p>Returns a reference to this lexicon. Identical in behavior to the += operator. </p>

</div>
</div>
<a id="a215fcead487aace2e89b04863e326ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215fcead487aace2e89b04863e326ba6">&#9670;&nbsp;</a></span>addWordsFromFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addWordsFromFile </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the given input stream and adds all of its words to the lexicon. </p>
<p>Each word from the stream is converted to lowercase before adding it. </p>

</div>
</div>
<a id="a3891deaa85aee9a52b6ca258d1514716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3891deaa85aee9a52b6ca258d1514716">&#9670;&nbsp;</a></span>addWordsFromFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addWordsFromFile </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the file and adds all of its words to the lexicon. </p>
<p>Each word from the file is converted to lowercase before adding it. </p>

</div>
</div>
<a id="a324ff6b85a0d392036efefc95b5d5e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324ff6b85a0d392036efefc95b5d5e83">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last value in the lexicon in alphabetical order. </p>
<p>If the set is empty, generates an error. </p>

</div>
</div>
<a id="a0c62c15c8ed609e7e5e9518cf5f5c712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c62c15c8ed609e7e5e9518cf5f5c712">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon_1_1iterator.html">iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator positioned at the first word in the lexicon. </p>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all words from the lexicon. </p>

</div>
</div>
<a id="a479b1bac4a3c243907c80e5c6f9b05d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479b1bac4a3c243907c80e5c6f9b05d5">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>word</code> is contained in the lexicon. </p>
<p>In the <code><a class="el" href="classLexicon.html" title="  This class is used to represent a lexicon, or word list. ">Lexicon</a></code> class, the case of letters is ignored, so "Zoo" is the same as "ZOO" or "zoo". The empty string cannot be contained in a lexicon, nor can any word containing any non-alphabetic characters such as punctuation or whitespace. </p>

</div>
</div>
<a id="a9cc56f4fc1106ca74a59fceb9d68b3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc56f4fc1106ca74a59fceb9d68b3e9">&#9670;&nbsp;</a></span>containsAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if every value from the given other lexicon is also found in this lexicon. </p>
<p>Equivalent in behavior to isSupersetOf. </p>

</div>
</div>
<a id="a3934298595e72e6540e5f81d47ab763a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3934298595e72e6540e5f81d47ab763a">&#9670;&nbsp;</a></span>containsAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsAll </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if every value from the given initializer list is also found in this lexicon. </p>
<p>Equivalent in behavior to isSupersetOf. </p>

</div>
</div>
<a id="a0b8e0b0b6f72ba6b88b56bd074b1dc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8e0b0b6f72ba6b88b56bd074b1dc32">&#9670;&nbsp;</a></span>containsPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsPrefix </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any words in the lexicon begin with <code>prefix</code>. </p>
<p>Like <code>containsWord</code>, this method ignores the case of letters so that "MO" is a prefix of "monkey" or "Monday". The empty string is a prefix of every string, so this method returns true when passed the empty string. </p>

</div>
</div>
<a id="a68b688a51bd0cf6fb5bc2cba292209a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b688a51bd0cf6fb5bc2cba292209a8">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon_1_1iterator.html">iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator positioned at the last word in the lexicon. </p>

</div>
</div>
<a id="a7dd6de171cb80bc7e2b48d53bd1e9276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd6de171cb80bc7e2b48d53bd1e9276">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two lexicons for equality. </p>

</div>
</div>
<a id="aba89eab0637bde14f9ded33e9e9c6aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba89eab0637bde14f9ded33e9e9c6aa5">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first value in the lexicon in alphabetical order. </p>
<p>If the set is empty, <code>first</code> generates an error. Equivalent to first. </p>

</div>
</div>
<a id="a054217ec9f3229ceedee9d7bde075587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054217ec9f3229ceedee9d7bde075587">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first value in the lexicon in alphabetical order. </p>
<p>If the set is empty, generates an error. Equivalent to first. </p>

</div>
</div>
<a id="a1a017af6eb755b5c83e70f61e2bda2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a017af6eb755b5c83e70f61e2bda2c7">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to this lexicon, if it was not already there. </p>
<p>This method is exported for compatibility with the STL <code>set</code> class. </p>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the lexicon contains no words. </p>

</div>
</div>
<a id="a6c118f41dad8941a624c3ff479987e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c118f41dad8941a624c3ff479987e3d">&#9670;&nbsp;</a></span>isSubsetOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubsetOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether every word of this lexicon is contained in the given set. </p>

</div>
</div>
<a id="a2a0f1241b53bcf0b31103b79cb01b87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0f1241b53bcf0b31103b79cb01b87d">&#9670;&nbsp;</a></span>isSubsetOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubsetOf </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether every word of this lexicon is contained in the given initializer list. </p>

</div>
</div>
<a id="ad6a4796a72905df1e33f4b100cb91f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a4796a72905df1e33f4b100cb91f32">&#9670;&nbsp;</a></span>isSupersetOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSupersetOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether every word of the given lexicon is contained in this lexicon. </p>
<p>Equivalent in behavior to containsAll. </p>

</div>
</div>
<a id="a217cbc1e6ba9f694645608c8a17c1943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217cbc1e6ba9f694645608c8a17c1943">&#9670;&nbsp;</a></span>isSupersetOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSupersetOf </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether every word of the given list is contained in this lexicon. </p>
<p>Equivalent in behavior to containsAll. </p>

</div>
</div>
<a id="a2e4e14ffb291ba4d5475b9b66d2a12c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4e14ffb291ba4d5475b9b66d2a12c8">&#9670;&nbsp;</a></span>mapAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mapAll </td>
          <td>(</td>
          <td class="paramtype">void(*)(string)&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the specified function on each word in the lexicon. </p>

</div>
</div>
<a id="abab83598d63d43b15cf018fa020e1ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab83598d63d43b15cf018fa020e1ddf">&#9670;&nbsp;</a></span>mapAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mapAll </td>
          <td>(</td>
          <td class="paramtype">void(*)(string )&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the specified function on each word in the lexicon. </p>

</div>
</div>
<a id="a8dc32c1e45704cfae41daf8adb4e66dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc32c1e45704cfae41daf8adb4e66dc">&#9670;&nbsp;</a></span>mapAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mapAll </td>
          <td>(</td>
          <td class="paramtype">FunctorType&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the specified function on each word in the lexicon. </p>

</div>
</div>
<a id="af42d8a30a8c4b2d33a6be3b12258e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42d8a30a8c4b2d33a6be3b12258e152">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if two lexicons do not have the same elements. </p>

</div>
</div>
<a id="a62286f0f5d7c1229b3003b855bf54ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62286f0f5d7c1229b3003b855bf54ba3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of two lexicons, which is the set of all words that appear in both. </p>

</div>
</div>
<a id="a5da3a8f0f6332bccefe7b2cb48d8a8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da3a8f0f6332bccefe7b2cb48d8a8d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator* </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of this lexicons and the given list, which is the set of all words that appear in both. </p>

</div>
</div>
<a id="ab81e3c0d6a5637202849784ef00b9cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81e3c0d6a5637202849784ef00b9cd5">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any elements from this lexicon that are not present in <code>lex2</code>. </p>

</div>
</div>
<a id="a79ada3cb64d9f074114ce895c67be781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ada3cb64d9f074114ce895c67be781">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any elements from this lexicon that are not present in the given initializer list. </p>

</div>
</div>
<a id="acfc41a903b549304f3b70e48fd2e52e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc41a903b549304f3b70e48fd2e52e4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the union of lexicons <code>lex1</code> and <code>lex2</code>, which is the set of words that appear in at least one of the two. </p>

</div>
</div>
<a id="a4436a915b6de75438364ed061e0e9491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4436a915b6de75438364ed061e0e9491">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the union of this lexicon and the words in the given list, which is the set of words that appear in at least one of the two. </p>

</div>
</div>
<a id="a44774af5311cf2c8fd054ecf8ff8e76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44774af5311cf2c8fd054ecf8ff8e76b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the union of this lexicon and the given word. </p>

</div>
</div>
<a id="afa70421c28007f127e7c4b24666ecc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70421c28007f127e7c4b24666ecc3a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all of the words from the given lexicon to this lexicon. </p>

</div>
</div>
<a id="a3080ac30a072160945adc5f860ca1785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3080ac30a072160945adc5f860ca1785">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all of the words from the given list to this lexicon. </p>

</div>
</div>
<a id="a051f30ebfa7b8fbb7ea1dc5af23d3004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051f30ebfa7b8fbb7ea1dc5af23d3004">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified word to this lexicon. </p>

</div>
</div>
<a id="a75f32eb2f65c3c3968193cfd72bdfd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f32eb2f65c3c3968193cfd72bdfd1a">&#9670;&nbsp;</a></span>operator,()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator, </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a487624601a6357e1b6d64053f9ebb5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487624601a6357e1b6d64053f9ebb5e2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the difference of two lexicons, which is all of the words that appear in <code>lex1</code> but not <code>lex2</code>. </p>
<p>You can also pass an initializer list such as {"a", "b", "c"}. The right hand set can be replaced by a single word, in which case the operator returns a new lexicon formed by removing that word. </p>

</div>
</div>
<a id="a0cd415d08567bfae9eae12afe2169cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd415d08567bfae9eae12afe2169cb5">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator- </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the difference of two lexicons, which is all of the words that appear in this lexicon but not in the given initializer list. </p>

</div>
</div>
<a id="a14c8fea4b958b02ea5ee55d5509db8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c8fea4b958b02ea5ee55d5509db8e6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> operator- </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new lexicon formed by removing the given word from this lexicon. </p>

</div>
</div>
<a id="ac51e54102d6257c1a0a48c99ad2520f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51e54102d6257c1a0a48c99ad2520f6">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements in the given lexicon from this lexicon. </p>

</div>
</div>
<a id="a1b3ac9124341c069a604d760190789b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3ac9124341c069a604d760190789b1">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements in the given list from this lexicon. </p>

</div>
</div>
<a id="a4acb1cafdecdbf77b1d62f2372a6d244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acb1cafdecdbf77b1d62f2372a6d244">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given word from this lexicon. </p>

</div>
</div>
<a id="aad808851ca0fffc8b60fd0b69ad097bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad808851ca0fffc8b60fd0b69ad097bd">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two lexicons. </p>

</div>
</div>
<a id="a236ec3f5ec721fb4ca4551bf49123eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236ec3f5ec721fb4ca4551bf49123eac">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two lexicons. </p>

</div>
</div>
<a id="ab9766b3af1f48ed51a1bcf037e08de43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9766b3af1f48ed51a1bcf037e08de43">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fcab616682564bf55eb0b096a35219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcab616682564bf55eb0b096a35219d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if two lexicons have the same elements. </p>

</div>
</div>
<a id="a04139ff41f8d25adbf5958ff2b01b068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04139ff41f8d25adbf5958ff2b01b068">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two lexicons. </p>

</div>
</div>
<a id="a05b7f6593b8b859858cf21ffbc9e5ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b7f6593b8b859858cf21ffbc9e5ab1">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two lexicons. </p>

</div>
</div>
<a id="affc6169b054fb3bbc4d72694e1a5834e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc6169b054fb3bbc4d72694e1a5834e">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool remove </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified word from the lexicon, if it was present. </p>
<p>Returns true if the word was previously contained in the lexicon; in other words, if a word was removed. The empty string cannot be contained in a lexicon, so passing the empty string to this method returns false. </p>

</div>
</div>
<a id="a606a7338945745d8ac9ce21f456f08d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606a7338945745d8ac9ce21f456f08d9">&#9670;&nbsp;</a></span>removeAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; removeAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements of the given other lexicon from this lexicon. </p>
<p>Returns a reference to this lexicon. Identical in behavior to the -= operator. </p>

</div>
</div>
<a id="a8ef0b8a849b2d33d83bc9689c4c4d090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef0b8a849b2d33d83bc9689c4c4d090">&#9670;&nbsp;</a></span>removeAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; removeAll </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements of the given other list from this lexicon. </p>
<p>Returns a reference to this lexicon. Identical in behavior to the -= operator. </p>

</div>
</div>
<a id="a998af18a2f0af7d18ce689acee75ca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998af18a2f0af7d18ce689acee75ca59">&#9670;&nbsp;</a></span>removePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool removePrefix </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all words from the lexicon that begin with the given prefix. </p>
<p>Returns true if the prefix was previously contained in the lexicon; in other words, if any words were removed. If the empty string is passed, since all words begin with the empty string, all words will be removed and this method will return true if the lexicon was non-empty prior to the call. </p>

</div>
</div>
<a id="a38501eec95ff302cb83dae17ab478b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38501eec95ff302cb83dae17ab478b81">&#9670;&nbsp;</a></span>retainAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; retainAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from this lexicon that are not contained in the given other lexicon. </p>
<p>Returns a reference to this lexicon. Identical in behavior to the *= operator. </p>

</div>
</div>
<a id="a17b175aadba16c14093da01963914b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b175aadba16c14093da01963914b33">&#9670;&nbsp;</a></span>retainAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLexicon.html">Lexicon</a> &amp; retainAll </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; string &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from this lexicon that are not contained in the given initializer list. </p>
<p>Returns a reference to this lexicon. Identical in behavior to the *= operator. </p>

</div>
</div>
<a id="af9593d4a5ff4274efaf429cb4f9e57cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9593d4a5ff4274efaf429cb4f9e57cc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of words contained in the lexicon. </p>

</div>
</div>
<a id="a1fe5121d6528fdea3f243321b3fa3a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5121d6528fdea3f243321b3fa3a49">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the lexicon to a printable string representation such as <code>{"a", "b", "c"}</code>. </p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this can be an expensive operation if the lexicon contains a large number of words. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af4dde954854b1ec1072266b3042d44a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dde954854b1ec1072266b3042d44a6">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the lexicon to the given output stream. </p>

</div>
</div>
<a id="a1f966ac4d3b3849aa4bc556d995c24ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f966ac4d3b3849aa4bc556d995c24ba">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLexicon.html">Lexicon</a> &amp;&#160;</td>
          <td class="paramname"><em>lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the contents of a lexicon from the given input stream. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
