<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StanfordCPPLib: GenericSet&lt; SetTraits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StanfordCPPLib
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestanfordcpplib.html">stanfordcpplib</a></li><li class="navelem"><a class="el" href="namespacestanfordcpplib_1_1collections.html">collections</a></li><li class="navelem"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstanfordcpplib_1_1collections_1_1GenericSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GenericSet&lt; SetTraits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><h2>Class: GenericSet&lt;SetTraits&gt; </h2>
This class stores a collection of distinct elements.  
 <a href="classstanfordcpplib_1_1collections_1_1GenericSet.html#details">More...</a></p>

<p><code>#include "<a class="el" href="collections_8h_source.html">collections.h</a>"</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a49eb513fe04e245250a4aebfb1ac768a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a49eb513fe04e245250a4aebfb1ac768a">const_iterator</a> = typename <a class="el" href="classMap.html#a04e3b848cce2bbfed5ea818e1b264000">SetTraits::MapType::const_iterator</a></td></tr>
<tr class="separator:a49eb513fe04e245250a4aebfb1ac768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d10e70baaeac78e76b7abae7e2cf76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab3d10e70baaeac78e76b7abae7e2cf76">iterator</a> = <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a49eb513fe04e245250a4aebfb1ac768a">const_iterator</a></td></tr>
<tr class="separator:ab3d10e70baaeac78e76b7abae7e2cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669c81f158766925e7293f97c0099b28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> = typename <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html#aecaeabaa9da616ae42bb20787878260d">SetTraits::ValueType</a></td></tr>
<tr class="memdesc:a669c81f158766925e7293f97c0099b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility alias to make things easier to work with.  <a href="#a669c81f158766925e7293f97c0099b28">More...</a><br /></td></tr>
<tr class="separator:a669c81f158766925e7293f97c0099b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a509ac9cd7429d3187594beced88d4921"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a509ac9cd7429d3187594beced88d4921">GenericSet</a>()=default</td></tr>
<tr class="memdesc:a509ac9cd7429d3187594beced88d4921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> </p><h2>Usage: GenericSet&lt;ValueType, SetTraits&gt; set; </h2>
Initializes an empty set of the specified element type.  <a href="#a509ac9cd7429d3187594beced88d4921">More...</a><br /></td></tr>
<tr class="separator:a509ac9cd7429d3187594beced88d4921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bac19c4194012a2724702caf3a15e20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a6bac19c4194012a2724702caf3a15e20">GenericSet</a>(std::initializer_list&lt; <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &gt; list)</td></tr>
<tr class="memdesc:a6bac19c4194012a2724702caf3a15e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> </p><h2>Usage: GenericSet&lt;ValueType, SetTraits&gt; set {1, 2, 3}; </h2>
Initializes a new set that stores the given elements.  <a href="#a6bac19c4194012a2724702caf3a15e20">More...</a><br /></td></tr>
<tr class="separator:a6bac19c4194012a2724702caf3a15e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd375e42dcb08298b04d3425d2b95d7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abcd375e42dcb08298b04d3425d2b95d7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#abcd375e42dcb08298b04d3425d2b95d7">GenericSet</a>(Args... args)</td></tr>
<tr class="memdesc:abcd375e42dcb08298b04d3425d2b95d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> Usage: GenericSet&lt;ValueType, SetTraits&gt; set(...  <a href="#abcd375e42dcb08298b04d3425d2b95d7">More...</a><br /></td></tr>
<tr class="separator:abcd375e42dcb08298b04d3425d2b95d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5f987c2f3dc9708bed63dd9c80b5fa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aae5f987c2f3dc9708bed63dd9c80b5fa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#aae5f987c2f3dc9708bed63dd9c80b5fa">GenericSet</a>(std::initializer_list&lt; <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &gt; list, Args... args)</td></tr>
<tr class="memdesc:aae5f987c2f3dc9708bed63dd9c80b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> Usage: GenericSet&lt;ValueType, SetTraits&gt; set({1, 2, 3}, ...  <a href="#aae5f987c2f3dc9708bed63dd9c80b5fa">More...</a><br /></td></tr>
<tr class="separator:aae5f987c2f3dc9708bed63dd9c80b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab221b36dcc150632e4f355130d16f377"><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab221b36dcc150632e4f355130d16f377">~GenericSet</a>()=default</td></tr>
<tr class="memdesc:ab221b36dcc150632e4f355130d16f377"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2>Destructor: ~Set </h2>
Frees any heap storage associated with this set.  <a href="#ab221b36dcc150632e4f355130d16f377">More...</a><br /></td></tr>
<tr class="separator:ab221b36dcc150632e4f355130d16f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfcf4823a6ebadb0244d0943e5ea727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a7cfcf4823a6ebadb0244d0943e5ea727">add</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a7cfcf4823a6ebadb0244d0943e5ea727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: add </p><h2>Usage: set.add(value); </h2>
Adds an element to this set, if it was not already there.  <a href="#a7cfcf4823a6ebadb0244d0943e5ea727">More...</a><br /></td></tr>
<tr class="separator:a7cfcf4823a6ebadb0244d0943e5ea727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f4cd8986fd068b79d2a69a79348a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ad7f4cd8986fd068b79d2a69a79348a7e">addAll</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set)</td></tr>
<tr class="memdesc:ad7f4cd8986fd068b79d2a69a79348a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: addAll </p><h2>Usage: set.addAll(set2); </h2>
Adds all elements of the given other set to this set.  <a href="#ad7f4cd8986fd068b79d2a69a79348a7e">More...</a><br /></td></tr>
<tr class="separator:ad7f4cd8986fd068b79d2a69a79348a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b351b4cfc065bb0eee5d8c7404c3147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a4b351b4cfc065bb0eee5d8c7404c3147">back</a>() const</td></tr>
<tr class="memdesc:a4b351b4cfc065bb0eee5d8c7404c3147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: back </p><h2>Usage: ValueType value = set.back(); </h2>
Returns the last value in the set in the order established by the <code>foreach</code> macro.  <a href="#a4b351b4cfc065bb0eee5d8c7404c3147">More...</a><br /></td></tr>
<tr class="separator:a4b351b4cfc065bb0eee5d8c7404c3147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c62c15c8ed609e7e5e9518cf5f5c712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab3d10e70baaeac78e76b7abae7e2cf76">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a0c62c15c8ed609e7e5e9518cf5f5c712">begin</a>() const</td></tr>
<tr class="separator:a0c62c15c8ed609e7e5e9518cf5f5c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: clear </p><h2>Usage: set.clear(); </h2>
Removes all elements from this set.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b67116c496b2347931664ac27c37921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a9b67116c496b2347931664ac27c37921">contains</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value) const</td></tr>
<tr class="memdesc:a9b67116c496b2347931664ac27c37921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: contains Usage: if (set.contains(value)) ...  <a href="#a9b67116c496b2347931664ac27c37921">More...</a><br /></td></tr>
<tr class="separator:a9b67116c496b2347931664ac27c37921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa27e9ac99d4d889625d3989b40f0b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#abaa27e9ac99d4d889625d3989b40f0b6">containsAll</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:abaa27e9ac99d4d889625d3989b40f0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: containsAll Usage: if (set.containsAll(set2)) ...  <a href="#abaa27e9ac99d4d889625d3989b40f0b6">More...</a><br /></td></tr>
<tr class="separator:abaa27e9ac99d4d889625d3989b40f0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6112917491bf7803154d808ad93518d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#af6112917491bf7803154d808ad93518d">difference</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set)</td></tr>
<tr class="memdesc:af6112917491bf7803154d808ad93518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: difference </p><h2>Usage: set.difference(set2); </h2>
Removes all elements of the given other set from this set.  <a href="#af6112917491bf7803154d808ad93518d">More...</a><br /></td></tr>
<tr class="separator:af6112917491bf7803154d808ad93518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b688a51bd0cf6fb5bc2cba292209a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab3d10e70baaeac78e76b7abae7e2cf76">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a68b688a51bd0cf6fb5bc2cba292209a8">end</a>() const</td></tr>
<tr class="separator:a68b688a51bd0cf6fb5bc2cba292209a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f6c12b7eb171e7b5e3725f04f3c1f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#af0f6c12b7eb171e7b5e3725f04f3c1f3">equals</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:af0f6c12b7eb171e7b5e3725f04f3c1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: equals Usage: if (set.equals(set2)) ...  <a href="#af0f6c12b7eb171e7b5e3725f04f3c1f3">More...</a><br /></td></tr>
<tr class="separator:af0f6c12b7eb171e7b5e3725f04f3c1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645a432ab2e8069945e37c3adc9a7ff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a645a432ab2e8069945e37c3adc9a7ff5">first</a>() const</td></tr>
<tr class="memdesc:a645a432ab2e8069945e37c3adc9a7ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: first </p><h2>Usage: ValueType value = set.first(); </h2>
Returns the first value in the set in the order established by the <code>foreach</code> macro.  <a href="#a645a432ab2e8069945e37c3adc9a7ff5">More...</a><br /></td></tr>
<tr class="separator:a645a432ab2e8069945e37c3adc9a7ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9f0cc6419ef7e036df4eeac4825b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a9c9f0cc6419ef7e036df4eeac4825b2c">front</a>() const</td></tr>
<tr class="memdesc:a9c9f0cc6419ef7e036df4eeac4825b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: front </p><h2>Usage: ValueType value = set.front(); </h2>
Returns the first value in the set in the order established by the <code>foreach</code> macro.  <a href="#a9c9f0cc6419ef7e036df4eeac4825b2c">More...</a><br /></td></tr>
<tr class="separator:a9c9f0cc6419ef7e036df4eeac4825b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81ff41776176f38b1a5c616f1815831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#aa81ff41776176f38b1a5c616f1815831">insert</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:aa81ff41776176f38b1a5c616f1815831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: insert </p><h2>Usage: set.insert(value); </h2>
Adds an element to this set, if it was not already there.  <a href="#aa81ff41776176f38b1a5c616f1815831">More...</a><br /></td></tr>
<tr class="separator:aa81ff41776176f38b1a5c616f1815831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1892695645d8f29cbc6c8587500f2829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a1892695645d8f29cbc6c8587500f2829">intersect</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set)</td></tr>
<tr class="memdesc:a1892695645d8f29cbc6c8587500f2829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: intersect </p><h2>Usage: set.intersect(set2); </h2>
Removes all elements from this set that are not contained in the given other set.  <a href="#a1892695645d8f29cbc6c8587500f2829">More...</a><br /></td></tr>
<tr class="separator:a1892695645d8f29cbc6c8587500f2829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a>() const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: isEmpty Usage: if (set.isEmpty()) ...  <a href="#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ce41f03d31f89935db1f3f5fdffc2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#af8ce41f03d31f89935db1f3f5fdffc2c">isSubsetOf</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:af8ce41f03d31f89935db1f3f5fdffc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: isSubsetOf Usage: if (set.isSubsetOf(set2)) ...  <a href="#af8ce41f03d31f89935db1f3f5fdffc2c">More...</a><br /></td></tr>
<tr class="separator:af8ce41f03d31f89935db1f3f5fdffc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074ab19fab73dfcff220d4b64aa5be82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a074ab19fab73dfcff220d4b64aa5be82">isSupersetOf</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:a074ab19fab73dfcff220d4b64aa5be82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: isSupersetOf Usage: if (set.isSupersetOf(set2)) ...  <a href="#a074ab19fab73dfcff220d4b64aa5be82">More...</a><br /></td></tr>
<tr class="separator:a074ab19fab73dfcff220d4b64aa5be82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ca00030776c68af16559092a3856a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#af2ca00030776c68af16559092a3856a4">mapAll</a>(std::function&lt; void(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;)&gt; fn) const</td></tr>
<tr class="memdesc:af2ca00030776c68af16559092a3856a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: mapAll </p><h2>Usage: set.mapAll(fn); </h2>
Iterates through the elements of the set and calls <code>fn(value)</code> for each one.  <a href="#af2ca00030776c68af16559092a3856a4">More...</a><br /></td></tr>
<tr class="separator:af2ca00030776c68af16559092a3856a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da26ab6a8320bed56ef83210a0addf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a2da26ab6a8320bed56ef83210a0addf8">operator!=</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:a2da26ab6a8320bed56ef83210a0addf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator: != </p><h2>Usage: set1 != set2 </h2>
Returns <code>true</code> if <code>set1</code> and <code>set2</code> are different.  <a href="#a2da26ab6a8320bed56ef83210a0addf8">More...</a><br /></td></tr>
<tr class="separator:a2da26ab6a8320bed56ef83210a0addf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834d22cfc42c67b0243283c3bc02ce5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a834d22cfc42c67b0243283c3bc02ce5e">operator*</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:a834d22cfc42c67b0243283c3bc02ce5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator: * </p><h2>Usage: set1 * set2 </h2>
Returns the intersection of sets <code>set1</code> and <code>set2</code>, which is the set of all elements that appear in both.  <a href="#a834d22cfc42c67b0243283c3bc02ce5e">More...</a><br /></td></tr>
<tr class="separator:a834d22cfc42c67b0243283c3bc02ce5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1528986f737cd2163e1361e0bf326957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a1528986f737cd2163e1361e0bf326957">operator*=</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2)</td></tr>
<tr class="memdesc:a1528986f737cd2163e1361e0bf326957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator: *= </p><h2>Usage: set1 *= set2; </h2>
Removes any elements from <code>set1</code> that are not present in <code>set2</code>.  <a href="#a1528986f737cd2163e1361e0bf326957">More...</a><br /></td></tr>
<tr class="separator:a1528986f737cd2163e1361e0bf326957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea3af6c9d038b2965e152623d790723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#afea3af6c9d038b2965e152623d790723">operator+</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:afea3af6c9d038b2965e152623d790723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator: + Usage: set1 + set2 </p><h2>set1 + element </h2>
Returns the union of sets <code>set1</code> and <code>set2</code>, which is the set of elements that appear in at least one of the two sets.  <a href="#afea3af6c9d038b2965e152623d790723">More...</a><br /></td></tr>
<tr class="separator:afea3af6c9d038b2965e152623d790723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa15583f3e2d538799d56f6ac04608b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#afa15583f3e2d538799d56f6ac04608b9">operator+</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;element) const</td></tr>
<tr class="separator:afa15583f3e2d538799d56f6ac04608b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79734e82170dc5c5c9304a9d1898d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#af79734e82170dc5c5c9304a9d1898d57">operator+=</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2)</td></tr>
<tr class="memdesc:af79734e82170dc5c5c9304a9d1898d57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
 Operator: += Usage: set1 += set2; </p><h2>set1 += value; </h2>
Adds all of the elements from <code>set2</code> (or the single specified value) to <code>set1</code>.  <a href="#af79734e82170dc5c5c9304a9d1898d57">More...</a><br /></td></tr>
<tr class="separator:af79734e82170dc5c5c9304a9d1898d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b0925fd317fb30201e28139c7370e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a47b0925fd317fb30201e28139c7370e5">operator+=</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value)</td></tr>
<tr class="separator:a47b0925fd317fb30201e28139c7370e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2860c6b9af5560b816dd9f10dc13f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ad2860c6b9af5560b816dd9f10dc13f27">operator,</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value)</td></tr>
<tr class="separator:ad2860c6b9af5560b816dd9f10dc13f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5996e7e22f84d81f44c2402c2493d43b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a5996e7e22f84d81f44c2402c2493d43b">operator-</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:a5996e7e22f84d81f44c2402c2493d43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator: - Usage: set1 - set2 </p><h2>set1 - element </h2>
Returns the difference of sets <code>set1</code> and <code>set2</code>, which is all of the elements that appear in <code>set1</code> but not <code>set2</code>.  <a href="#a5996e7e22f84d81f44c2402c2493d43b">More...</a><br /></td></tr>
<tr class="separator:a5996e7e22f84d81f44c2402c2493d43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c09cbefc6834fc9010e209c8ce90765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a4c09cbefc6834fc9010e209c8ce90765">operator-</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;element) const</td></tr>
<tr class="separator:a4c09cbefc6834fc9010e209c8ce90765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffcff306f0a21b87fc0eb99343a2719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#adffcff306f0a21b87fc0eb99343a2719">operator-=</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2)</td></tr>
<tr class="memdesc:adffcff306f0a21b87fc0eb99343a2719"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
 Operator: -= Usage: set1 -= set2; </p><h2>set1 -= value; </h2>
Removes the elements from <code>set2</code> (or the single specified value) from <code>set1</code>.  <a href="#adffcff306f0a21b87fc0eb99343a2719">More...</a><br /></td></tr>
<tr class="separator:adffcff306f0a21b87fc0eb99343a2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4b3d414008341cbea6e24f14a2ee11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a6c4b3d414008341cbea6e24f14a2ee11">operator-=</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value)</td></tr>
<tr class="separator:a6c4b3d414008341cbea6e24f14a2ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f956a22921c1683b74783b055bbb2b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a7f956a22921c1683b74783b055bbb2b5">operator==</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set2) const</td></tr>
<tr class="memdesc:a7f956a22921c1683b74783b055bbb2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator: == </p><h2>Usage: set1 == set2 </h2>
Returns <code>true</code> if <code>set1</code> and <code>set2</code> contain the same elements.  <a href="#a7f956a22921c1683b74783b055bbb2b5">More...</a><br /></td></tr>
<tr class="separator:a7f956a22921c1683b74783b055bbb2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab522af639e5f45b032943bc611de79db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab522af639e5f45b032943bc611de79db">remove</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:ab522af639e5f45b032943bc611de79db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: remove </p><h2>Usage: set.remove(value); </h2>
Removes an element from this set.  <a href="#ab522af639e5f45b032943bc611de79db">More...</a><br /></td></tr>
<tr class="separator:ab522af639e5f45b032943bc611de79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fc29f868cd2ce2668788198e8a05a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a59fc29f868cd2ce2668788198e8a05a7">removeAll</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set)</td></tr>
<tr class="memdesc:a59fc29f868cd2ce2668788198e8a05a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: removeAll </p><h2>Usage: set.removeAll(set2); </h2>
Removes all elements of the given other set from this set.  <a href="#a59fc29f868cd2ce2668788198e8a05a7">More...</a><br /></td></tr>
<tr class="separator:a59fc29f868cd2ce2668788198e8a05a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b39be914ac3e2ecb6f0d14ab893f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a15b39be914ac3e2ecb6f0d14ab893f9a">retainAll</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set)</td></tr>
<tr class="memdesc:a15b39be914ac3e2ecb6f0d14ab893f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: retainAll </p><h2>Usage: set.retainAll(set2); </h2>
Removes all elements from this set that are not contained in the given other set.  <a href="#a15b39be914ac3e2ecb6f0d14ab893f9a">More...</a><br /></td></tr>
<tr class="separator:a15b39be914ac3e2ecb6f0d14ab893f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#af9593d4a5ff4274efaf429cb4f9e57cc">size</a>() const</td></tr>
<tr class="memdesc:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: size </p><h2>Usage: count = set.size(); </h2>
Returns the number of elements in this set.  <a href="#af9593d4a5ff4274efaf429cb4f9e57cc">More...</a><br /></td></tr>
<tr class="separator:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a1fe5121d6528fdea3f243321b3fa3a49">toString</a>() const</td></tr>
<tr class="memdesc:a1fe5121d6528fdea3f243321b3fa3a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: toString </p><h2>Usage: string str = set.toString(); </h2>
Converts the set to a printable string representation.  <a href="#a1fe5121d6528fdea3f243321b3fa3a49">More...</a><br /></td></tr>
<tr class="separator:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa3b4d177e1794dbb3e6a414a5ec2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#affa3b4d177e1794dbb3e6a414a5ec2b3">unionWith</a>(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> &amp;set)</td></tr>
<tr class="memdesc:affa3b4d177e1794dbb3e6a414a5ec2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method: unionWith </p><h2>Usage: set.unionWith(set2); </h2>
Adds all elements of the given other set to this set.  <a href="#affa3b4d177e1794dbb3e6a414a5ec2b3">More...</a><br /></td></tr>
<tr class="separator:affa3b4d177e1794dbb3e6a414a5ec2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SetTraits&gt;<br />
class stanfordcpplib::collections::GenericSet&lt; SetTraits &gt;</h3>

<h2>Class: GenericSet&lt;SetTraits&gt; </h2>
<p>This class stores a collection of distinct elements. </p>
<p><a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> should be a type containing the following: </p><pre class="fragment">typename ValueType:          whatever is stored in the map
typename MapType:            should be a Map&lt;ValueType, bool&gt;
static string name():   should return the name of the type.
</pre><p>There's one more requirement: you need to define a function </p><pre class="fragment">template &lt;typename... Args&gt;
   static MapType construct(Args&amp;&amp;... args)
</pre><p>that constructs an internal MapType object with the specified arguments. This function should do something creative or clever to ensure that there is a nice compiler error generated in the event that the arguments are invalid, since otherwise the error is going to be deeply nested inside the <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> template.</p>
<p>This is not meant to be used directly by students. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a49eb513fe04e245250a4aebfb1ac768a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49eb513fe04e245250a4aebfb1ac768a">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a49eb513fe04e245250a4aebfb1ac768a">const_iterator</a> =  typename <a class="el" href="classMap.html#a04e3b848cce2bbfed5ea818e1b264000">SetTraits::MapType::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3d10e70baaeac78e76b7abae7e2cf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d10e70baaeac78e76b7abae7e2cf76">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab3d10e70baaeac78e76b7abae7e2cf76">iterator</a> =  <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a49eb513fe04e245250a4aebfb1ac768a">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a669c81f158766925e7293f97c0099b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669c81f158766925e7293f97c0099b28">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> =  typename <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html#aecaeabaa9da616ae42bb20787878260d">SetTraits::ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility alias to make things easier to work with. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a509ac9cd7429d3187594beced88d4921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509ac9cd7429d3187594beced88d4921">&#9670;&nbsp;</a></span>GenericSet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> </p><h2>Usage: GenericSet&lt;ValueType, SetTraits&gt; set; </h2>
Initializes an empty set of the specified element type. </p>

</div>
</div>
<a id="a6bac19c4194012a2724702caf3a15e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bac19c4194012a2724702caf3a15e20">&#9670;&nbsp;</a></span>GenericSet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> </p><h2>Usage: GenericSet&lt;ValueType, SetTraits&gt; set {1, 2, 3}; </h2>
Initializes a new set that stores the given elements. </p>

</div>
</div>
<a id="abcd375e42dcb08298b04d3425d2b95d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd375e42dcb08298b04d3425d2b95d7">&#9670;&nbsp;</a></span>GenericSet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> Usage: GenericSet&lt;ValueType, SetTraits&gt; set(... </p>
<h2>things for the map ...); </h2>
<p>Forwards the specified arguments down to the underlying <a class="el" href="classMap.html">Map</a> type. </p>

</div>
</div>
<a id="aae5f987c2f3dc9708bed63dd9c80b5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5f987c2f3dc9708bed63dd9c80b5fa">&#9670;&nbsp;</a></span>GenericSet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor: <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html" title="Class: GenericSet&lt;SetTraits&gt; This class stores a collection of distinct elements. ...">GenericSet</a> Usage: GenericSet&lt;ValueType, SetTraits&gt; set({1, 2, 3}, ... </p>
<h2>things for the map ...); </h2>
<p>Constructs a set using the specified elements, forwarding the arguments to the underlying map. </p>

</div>
</div>
<a id="ab221b36dcc150632e4f355130d16f377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab221b36dcc150632e4f355130d16f377">&#9670;&nbsp;</a></span>~GenericSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><h2>Destructor: ~Set </h2>
Frees any heap storage associated with this set. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7cfcf4823a6ebadb0244d0943e5ea727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfcf4823a6ebadb0244d0943e5ea727">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: add </p><h2>Usage: set.add(value); </h2>
Adds an element to this set, if it was not already there. </p>
<p>For compatibility with the STL <code>set</code> class, this method is also exported as <code>insert</code>. </p>

</div>
</div>
<a id="ad7f4cd8986fd068b79d2a69a79348a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f4cd8986fd068b79d2a69a79348a7e">&#9670;&nbsp;</a></span>addAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; addAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: addAll </p><h2>Usage: set.addAll(set2); </h2>
Adds all elements of the given other set to this set. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. Returns a reference to this set.</p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the + operator instead (not +=), which returns a newly created copy set.</p>
<p>Identical in behavior to the += operator. </p>

</div>
</div>
<a id="a4b351b4cfc065bb0eee5d8c7404c3147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b351b4cfc065bb0eee5d8c7404c3147">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt;::<a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: back </p><h2>Usage: ValueType value = set.back(); </h2>
Returns the last value in the set in the order established by the <code>foreach</code> macro. </p>
<p>If the set is empty, generates an error. </p>

</div>
</div>
<a id="a0c62c15c8ed609e7e5e9518cf5f5c712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c62c15c8ed609e7e5e9518cf5f5c712">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab3d10e70baaeac78e76b7abae7e2cf76">iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: clear </p><h2>Usage: set.clear(); </h2>
Removes all elements from this set. </p>

</div>
</div>
<a id="a9b67116c496b2347931664ac27c37921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b67116c496b2347931664ac27c37921">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: contains Usage: if (set.contains(value)) ... </p>
<hr/>
<p> Returns <code>true</code> if the specified value is in this set. </p>

</div>
</div>
<a id="abaa27e9ac99d4d889625d3989b40f0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa27e9ac99d4d889625d3989b40f0b6">&#9670;&nbsp;</a></span>containsAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: containsAll Usage: if (set.containsAll(set2)) ... </p>
<hr/>
<p> Returns <code>true</code> if every value from the given other set is also found in this set. You can also pass an initializer list such as {1, 2, 3}. Equivalent in behavior to isSupersetOf. </p>

</div>
</div>
<a id="af6112917491bf7803154d808ad93518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6112917491bf7803154d808ad93518d">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: difference </p><h2>Usage: set.difference(set2); </h2>
Removes all elements of the given other set from this set. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. Returns a reference to this set.</p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the - operator instead (not -=), which returns a newly created copy set.</p>
<p>Identical in behavior to the -= operator and the removeAll function. </p>

</div>
</div>
<a id="a68b688a51bd0cf6fb5bc2cba292209a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b688a51bd0cf6fb5bc2cba292209a8">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#ab3d10e70baaeac78e76b7abae7e2cf76">iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0f6c12b7eb171e7b5e3725f04f3c1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f6c12b7eb171e7b5e3725f04f3c1f3">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: equals Usage: if (set.equals(set2)) ... </p>
<hr/>
<p> Returns <code>true</code> if this set contains exactly the same values as the given other set. Identical in behavior to the == operator. </p>

</div>
</div>
<a id="a645a432ab2e8069945e37c3adc9a7ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645a432ab2e8069945e37c3adc9a7ff5">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt;::<a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: first </p><h2>Usage: ValueType value = set.first(); </h2>
Returns the first value in the set in the order established by the <code>foreach</code> macro. </p>
<p>If the set is empty, <code>first</code> generates an error. Equivalent to front. </p>

</div>
</div>
<a id="a9c9f0cc6419ef7e036df4eeac4825b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9f0cc6419ef7e036df4eeac4825b2c">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt;::<a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: front </p><h2>Usage: ValueType value = set.front(); </h2>
Returns the first value in the set in the order established by the <code>foreach</code> macro. </p>
<p>If the set is empty, generates an error. Equivalent to first. </p>

</div>
</div>
<a id="aa81ff41776176f38b1a5c616f1815831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81ff41776176f38b1a5c616f1815831">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: insert </p><h2>Usage: set.insert(value); </h2>
Adds an element to this set, if it was not already there. </p>
<p>This method is exported for compatibility with the STL <code>set</code> class. </p>

</div>
</div>
<a id="a1892695645d8f29cbc6c8587500f2829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1892695645d8f29cbc6c8587500f2829">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: intersect </p><h2>Usage: set.intersect(set2); </h2>
Removes all elements from this set that are not contained in the given other set. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. Returns a reference to this set.</p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the * operator instead (not *=), which returns a newly created copy set.</p>
<p>Identical in behavior to the *= operator and the retainAll function. </p>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: isEmpty Usage: if (set.isEmpty()) ... </p>
<hr/>
<p> Returns <code>true</code> if this set contains no elements. </p>

</div>
</div>
<a id="af8ce41f03d31f89935db1f3f5fdffc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ce41f03d31f89935db1f3f5fdffc2c">&#9670;&nbsp;</a></span>isSubsetOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubsetOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: isSubsetOf Usage: if (set.isSubsetOf(set2)) ... </p>
<hr/>
<p> Implements the subset relation on sets. It returns <code>true</code> if every element of this set is contained in <code>set2</code>. You can also pass an initializer list such as {1, 2, 3}. </p>

</div>
</div>
<a id="a074ab19fab73dfcff220d4b64aa5be82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074ab19fab73dfcff220d4b64aa5be82">&#9670;&nbsp;</a></span>isSupersetOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSupersetOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: isSupersetOf Usage: if (set.isSupersetOf(set2)) ... </p>
<hr/>
<p> Implements the superset relation on sets. It returns <code>true</code> if every element of this set is contained in <code>set2</code>. You can also pass an initializer list such as {1, 2, 3}. Equivalent in behavior to containsAll. </p>

</div>
</div>
<a id="af2ca00030776c68af16559092a3856a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ca00030776c68af16559092a3856a4">&#9670;&nbsp;</a></span>mapAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mapAll </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: mapAll </p><h2>Usage: set.mapAll(fn); </h2>
Iterates through the elements of the set and calls <code>fn(value)</code> for each one. </p>
<p>The iteration order matches the underlying order in which the elements are stored. For Set, this is sorted order according to the comparison function; for LinkedHashSet, this is the insertion order; and for HashSet, this is whatever order the elements happen to be in. </p>

</div>
</div>
<a id="a2da26ab6a8320bed56ef83210a0addf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da26ab6a8320bed56ef83210a0addf8">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator: != </p><h2>Usage: set1 != set2 </h2>
Returns <code>true</code> if <code>set1</code> and <code>set2</code> are different. </p>

</div>
</div>
<a id="a834d22cfc42c67b0243283c3bc02ce5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834d22cfc42c67b0243283c3bc02ce5e">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator: * </p><h2>Usage: set1 * set2 </h2>
Returns the intersection of sets <code>set1</code> and <code>set2</code>, which is the set of all elements that appear in both. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. </p>

</div>
</div>
<a id="a1528986f737cd2163e1361e0bf326957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1528986f737cd2163e1361e0bf326957">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator: *= </p><h2>Usage: set1 *= set2; </h2>
Removes any elements from <code>set1</code> that are not present in <code>set2</code>. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. </p>

</div>
</div>
<a id="afea3af6c9d038b2965e152623d790723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea3af6c9d038b2965e152623d790723">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator: + Usage: set1 + set2 </p><h2>set1 + element </h2>
Returns the union of sets <code>set1</code> and <code>set2</code>, which is the set of elements that appear in at least one of the two sets. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. The right hand set can be replaced by an element of the value type, in which case the operator returns a new set formed by adding that element. </p>

</div>
</div>
<a id="afa15583f3e2d538799d56f6ac04608b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa15583f3e2d538799d56f6ac04608b9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af79734e82170dc5c5c9304a9d1898d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79734e82170dc5c5c9304a9d1898d57">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
 Operator: += Usage: set1 += set2; </p><h2>set1 += value; </h2>
Adds all of the elements from <code>set2</code> (or the single specified value) to <code>set1</code>. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. As a convenience, the <code>Set</code> package also overloads the comma operator so that it is possible to initialize a set like this:</p>
<pre>
     Set&lt;int&gt; digits;
     digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
*</pre> 
</div>
</div>
<a id="a47b0925fd317fb30201e28139c7370e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b0925fd317fb30201e28139c7370e5">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2860c6b9af5560b816dd9f10dc13f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2860c6b9af5560b816dd9f10dc13f27">&#9670;&nbsp;</a></span>operator,()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&amp; operator, </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5996e7e22f84d81f44c2402c2493d43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5996e7e22f84d81f44c2402c2493d43b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator: - Usage: set1 - set2 </p><h2>set1 - element </h2>
Returns the difference of sets <code>set1</code> and <code>set2</code>, which is all of the elements that appear in <code>set1</code> but not <code>set2</code>. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. The right hand set can be replaced by an element of the value type, in which case the operator returns a new set formed by removing that element. </p>

</div>
</div>
<a id="a4c09cbefc6834fc9010e209c8ce90765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c09cbefc6834fc9010e209c8ce90765">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adffcff306f0a21b87fc0eb99343a2719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffcff306f0a21b87fc0eb99343a2719">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
 Operator: -= Usage: set1 -= set2; </p><h2>set1 -= value; </h2>
Removes the elements from <code>set2</code> (or the single specified value) from <code>set1</code>. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. As a convenience, the <code>Set</code> package also overloads the comma operator so that it is possible to remove multiple elements from a set like this:</p>
<pre>
     digits -= 0, 2, 4, 6, 8;
*</pre><p>which removes the values 0, 2, 4, 6, and 8 from the set <code>digits</code>. </p>

</div>
</div>
<a id="a6c4b3d414008341cbea6e24f14a2ee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4b3d414008341cbea6e24f14a2ee11">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f956a22921c1683b74783b055bbb2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f956a22921c1683b74783b055bbb2b5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator: == </p><h2>Usage: set1 == set2 </h2>
Returns <code>true</code> if <code>set1</code> and <code>set2</code> contain the same elements. </p>

</div>
</div>
<a id="ab522af639e5f45b032943bc611de79db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab522af639e5f45b032943bc611de79db">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html#a669c81f158766925e7293f97c0099b28">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: remove </p><h2>Usage: set.remove(value); </h2>
Removes an element from this set. </p>
<p>If the value was not contained in the set, no error is generated and the set remains unchanged. </p>

</div>
</div>
<a id="a59fc29f868cd2ce2668788198e8a05a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fc29f868cd2ce2668788198e8a05a7">&#9670;&nbsp;</a></span>removeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; removeAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: removeAll </p><h2>Usage: set.removeAll(set2); </h2>
Removes all elements of the given other set from this set. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. Returns a reference to this set.</p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the - operator instead (not -=), which returns a newly created copy set.</p>
<p>Identical in behavior to the -= operator and the difference function. </p>

</div>
</div>
<a id="a15b39be914ac3e2ecb6f0d14ab893f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b39be914ac3e2ecb6f0d14ab893f9a">&#9670;&nbsp;</a></span>retainAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; retainAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: retainAll </p><h2>Usage: set.retainAll(set2); </h2>
Removes all elements from this set that are not contained in the given other set. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. Returns a reference to this set.</p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the * operator instead (not *=), which returns a newly created copy set.</p>
<p>Identical in behavior to the *= operator and the intersect function. </p>

</div>
</div>
<a id="af9593d4a5ff4274efaf429cb4f9e57cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9593d4a5ff4274efaf429cb4f9e57cc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: size </p><h2>Usage: count = set.size(); </h2>
Returns the number of elements in this set. </p>

</div>
</div>
<a id="a1fe5121d6528fdea3f243321b3fa3a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5121d6528fdea3f243321b3fa3a49">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: toString </p><h2>Usage: string str = set.toString(); </h2>
Converts the set to a printable string representation. </p>

</div>
</div>
<a id="affa3b4d177e1794dbb3e6a414a5ec2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa3b4d177e1794dbb3e6a414a5ec2b3">&#9670;&nbsp;</a></span>unionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp; unionWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method: unionWith </p><h2>Usage: set.unionWith(set2); </h2>
Adds all elements of the given other set to this set. </p>
<p>You can also pass an initializer list such as {1, 2, 3}. Returns a reference to this set. Identical in behavior to the += operator and the addAll function.</p>
<p><a class="el" href="classNote.html" title="Each Note object represents a musical note or rest. ">Note</a> that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the + operator instead (not +=), which returns a newly created copy set.</p>
<p>(Implementation note: This function cannot be named 'union' because that is a C/C++ keyword.) </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0e54ba06df831323f5a7743ada2de6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e54ba06df831323f5a7743ada2de6be">&#9670;&nbsp;</a></span>hashCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hashCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; <a class="el" href="structstanfordcpplib_1_1collections_1_1SetTraits.html">SetTraits</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2c038f3c2f75cc78c062f0b3b16a411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c038f3c2f75cc78c062f0b3b16a411">&#9670;&nbsp;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operators: &lt;, &gt;, &lt;=, &gt;= Usage: if (set1 &lt;= set2) ... </p>
<h2>... </h2>
<p>Relational operators to compare two sets. The &lt;, &gt;, &lt;=, &gt;= operators require that the value type has a &lt; operator so that the elements can be compared pairwise.</p>
<p>These are implemented as friend functions so that if we fully instantiate this type, we don't get errors when using relational operators. </p>

</div>
</div>
<a id="a65e20d362dfabf8b6592439af08e9c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e20d362dfabf8b6592439af08e9c45">&#9670;&nbsp;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add56ec57acd73fce18db96d132e25212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add56ec57acd73fce18db96d132e25212">&#9670;&nbsp;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82f6e70e1615f32c9c24620b911d5806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f6e70e1615f32c9c24620b911d5806">&#9670;&nbsp;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">GenericSet</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
