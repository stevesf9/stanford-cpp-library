<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StanfordCPPLib: Graph&lt; NodeType, ArcType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StanfordCPPLib
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph&lt; NodeType, ArcType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a graph with the specified node and arc types.  
 <a href="classGraph.html#details">More...</a></p>

<p><code>#include "<a class="el" href="graph_8h_source.html">graph.h</a>"</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a695969c31e87f9e8319d74e5ca39024b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> = typename <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt;::const_iterator</td></tr>
<tr class="separator:a695969c31e87f9e8319d74e5ca39024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c40af42cad207665228815f0359bbd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0c40af42cad207665228815f0359bbd3">Graph</a>()=default</td></tr>
<tr class="memdesc:a0c40af42cad207665228815f0359bbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty graph.  <a href="#a0c40af42cad207665228815f0359bbd3">More...</a><br /></td></tr>
<tr class="separator:a0c40af42cad207665228815f0359bbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a604e5e9e4d68dbc10b312e59f678f"><td class="memItemLeft" align="right" valign="top"></td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af5a604e5e9e4d68dbc10b312e59f678f">~Graph</a>()</td></tr>
<tr class="memdesc:af5a604e5e9e4d68dbc10b312e59f678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the internal storage allocated to represent the graph.  <a href="#af5a604e5e9e4d68dbc10b312e59f678f">More...</a><br /></td></tr>
<tr class="separator:af5a604e5e9e4d68dbc10b312e59f678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e9fedd7110ae2fb6873c5e2d29941"><td class="memItemLeft" align="right" valign="top">ArcType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aad2e9fedd7110ae2fb6873c5e2d29941">addArc</a>(string n1, string n2)</td></tr>
<tr class="memdesc:aad2e9fedd7110ae2fb6873c5e2d29941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed arc to the graph from node n1 to n2.  <a href="#aad2e9fedd7110ae2fb6873c5e2d29941">More...</a><br /></td></tr>
<tr class="separator:aad2e9fedd7110ae2fb6873c5e2d29941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280d3cd76bab82df392ba91ed5257c6"><td class="memItemLeft" align="right" valign="top">ArcType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7280d3cd76bab82df392ba91ed5257c6">addArc</a>(NodeType *n1, NodeType *n2)</td></tr>
<tr class="memdesc:a7280d3cd76bab82df392ba91ed5257c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed arc to the graph from node n1 to n2.  <a href="#a7280d3cd76bab82df392ba91ed5257c6">More...</a><br /></td></tr>
<tr class="separator:a7280d3cd76bab82df392ba91ed5257c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b6553e579c03260253a2d731668dfa"><td class="memItemLeft" align="right" valign="top">ArcType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa1b6553e579c03260253a2d731668dfa">addArc</a>(ArcType *arc)</td></tr>
<tr class="memdesc:aa1b6553e579c03260253a2d731668dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given arc to the graph.  <a href="#aa1b6553e579c03260253a2d731668dfa">More...</a><br /></td></tr>
<tr class="separator:aa1b6553e579c03260253a2d731668dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd763aa09491315536b5d2734cd82b89"><td class="memItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acd763aa09491315536b5d2734cd82b89">addNode</a>(string name)</td></tr>
<tr class="memdesc:acd763aa09491315536b5d2734cd82b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph.  <a href="#acd763aa09491315536b5d2734cd82b89">More...</a><br /></td></tr>
<tr class="separator:acd763aa09491315536b5d2734cd82b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635fa78d72315816cef6c091acfa3882"><td class="memItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a635fa78d72315816cef6c091acfa3882">addNode</a>(NodeType *node)</td></tr>
<tr class="memdesc:a635fa78d72315816cef6c091acfa3882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph.  <a href="#a635fa78d72315816cef6c091acfa3882">More...</a><br /></td></tr>
<tr class="separator:a635fa78d72315816cef6c091acfa3882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b108b3354f5222d2c829dcd639fa7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0b108b3354f5222d2c829dcd639fa7a">arcCount</a>() const</td></tr>
<tr class="memdesc:ac0b108b3354f5222d2c829dcd639fa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arcs in the graph.  <a href="#ac0b108b3354f5222d2c829dcd639fa7a">More...</a><br /></td></tr>
<tr class="separator:ac0b108b3354f5222d2c829dcd639fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d59ef129bb56cc144ecc81c0affd34"><td class="memItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a27d59ef129bb56cc144ecc81c0affd34">back</a>() const</td></tr>
<tr class="memdesc:a27d59ef129bb56cc144ecc81c0affd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last node in the graph in the order as would be returned by a for-each loop or iterator.  <a href="#a27d59ef129bb56cc144ecc81c0affd34">More...</a><br /></td></tr>
<tr class="separator:a27d59ef129bb56cc144ecc81c0affd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a8950c46f4ac913207201b685e715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aea3a8950c46f4ac913207201b685e715">begin</a>() const</td></tr>
<tr class="memdesc:aea3a8950c46f4ac913207201b685e715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an STL iterator positioned at the first vertex in the graph.  <a href="#aea3a8950c46f4ac913207201b685e715">More...</a><br /></td></tr>
<tr class="separator:aea3a8950c46f4ac913207201b685e715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a>()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the graph to be empty, removing all nodes and arcs and freeing any heap storage used by their corresponding internal structures.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0ce1806df1c8070d997153363eecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a63f0ce1806df1c8070d997153363eecb">clearArcs</a>()</td></tr>
<tr class="memdesc:a63f0ce1806df1c8070d997153363eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all arcs from the graph, freeing the heap storage used by their corresponding internal structures.  <a href="#a63f0ce1806df1c8070d997153363eecb">More...</a><br /></td></tr>
<tr class="separator:a63f0ce1806df1c8070d997153363eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14def9e68896088fec7839e5da4fed27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a14def9e68896088fec7839e5da4fed27">clearArcs</a>(NodeType *node)</td></tr>
<tr class="memdesc:a14def9e68896088fec7839e5da4fed27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures.  <a href="#a14def9e68896088fec7839e5da4fed27">More...</a><br /></td></tr>
<tr class="separator:a14def9e68896088fec7839e5da4fed27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8ecb9c6768fff244b2be46319385cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2d8ecb9c6768fff244b2be46319385cc">clearArcs</a>(string name)</td></tr>
<tr class="memdesc:a2d8ecb9c6768fff244b2be46319385cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures.  <a href="#a2d8ecb9c6768fff244b2be46319385cc">More...</a><br /></td></tr>
<tr class="separator:a2d8ecb9c6768fff244b2be46319385cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca50139471975b82fdc6b1977bcfa4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9ca50139471975b82fdc6b1977bcfa4a">containsArc</a>(NodeType *node1, NodeType *node2) const</td></tr>
<tr class="memdesc:a9ca50139471975b82fdc6b1977bcfa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists an arc directly between the given two nodes.  <a href="#a9ca50139471975b82fdc6b1977bcfa4a">More...</a><br /></td></tr>
<tr class="separator:a9ca50139471975b82fdc6b1977bcfa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515e45aae316b581bf1cf168541f4f44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a515e45aae316b581bf1cf168541f4f44">containsArc</a>(string node1, string node2) const</td></tr>
<tr class="memdesc:a515e45aae316b581bf1cf168541f4f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists an arc directly between the given two nodes.  <a href="#a515e45aae316b581bf1cf168541f4f44">More...</a><br /></td></tr>
<tr class="separator:a515e45aae316b581bf1cf168541f4f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a659ddd8a143836b91b01c200ee8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acf7a659ddd8a143836b91b01c200ee8a">containsArc</a>(ArcType *arc) const</td></tr>
<tr class="memdesc:acf7a659ddd8a143836b91b01c200ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given arc exists in this graph.  <a href="#acf7a659ddd8a143836b91b01c200ee8a">More...</a><br /></td></tr>
<tr class="separator:acf7a659ddd8a143836b91b01c200ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0beb77e8a238c2898ab851df71eeefe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0beb77e8a238c2898ab851df71eeefe">containsNode</a>(string name) const</td></tr>
<tr class="memdesc:ac0beb77e8a238c2898ab851df71eeefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a node in this graph with the given name.  <a href="#ac0beb77e8a238c2898ab851df71eeefe">More...</a><br /></td></tr>
<tr class="separator:ac0beb77e8a238c2898ab851df71eeefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f540ebc07c4e46a0bb7fee76a93386c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4f540ebc07c4e46a0bb7fee76a93386c">containsNode</a>(NodeType *node) const</td></tr>
<tr class="memdesc:a4f540ebc07c4e46a0bb7fee76a93386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node is part of this graph.  <a href="#a4f540ebc07c4e46a0bb7fee76a93386c">More...</a><br /></td></tr>
<tr class="separator:a4f540ebc07c4e46a0bb7fee76a93386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf62cae5d7e50644957d66f886742d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afcdf62cae5d7e50644957d66f886742d">end</a>() const</td></tr>
<tr class="memdesc:afcdf62cae5d7e50644957d66f886742d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an STL iterator positioned after the last vertex in the graph.  <a href="#afcdf62cae5d7e50644957d66f886742d">More...</a><br /></td></tr>
<tr class="separator:afcdf62cae5d7e50644957d66f886742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bec43eb3dfdf3d23eb328b406edf44a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6bec43eb3dfdf3d23eb328b406edf44a">equals</a>(const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;graph2) const</td></tr>
<tr class="memdesc:a6bec43eb3dfdf3d23eb328b406edf44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two graphs for equality.  <a href="#a6bec43eb3dfdf3d23eb328b406edf44a">More...</a><br /></td></tr>
<tr class="separator:a6bec43eb3dfdf3d23eb328b406edf44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7c2c1738f8e7faf84c54d7642992fa"><td class="memItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7b7c2c1738f8e7faf84c54d7642992fa">front</a>() const</td></tr>
<tr class="memdesc:a7b7c2c1738f8e7faf84c54d7642992fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first node in the graph in the order as would be returned by a for-each loop or iterator.  <a href="#a7b7c2c1738f8e7faf84c54d7642992fa">More...</a><br /></td></tr>
<tr class="separator:a7b7c2c1738f8e7faf84c54d7642992fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33db338f839ff9e3dafe4fe61c16fd"><td class="memItemLeft" align="right" valign="top">ArcType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7c33db338f839ff9e3dafe4fe61c16fd">getArc</a>(NodeType *node1, NodeType *node2) const</td></tr>
<tr class="memdesc:a7c33db338f839ff9e3dafe4fe61c16fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arc, if any, from node1 to node2.  <a href="#a7c33db338f839ff9e3dafe4fe61c16fd">More...</a><br /></td></tr>
<tr class="separator:a7c33db338f839ff9e3dafe4fe61c16fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4badfc856b0d4530c37121efb9834"><td class="memItemLeft" align="right" valign="top">ArcType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a94d4badfc856b0d4530c37121efb9834">getArc</a>(string node1, string node2) const</td></tr>
<tr class="memdesc:a94d4badfc856b0d4530c37121efb9834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arc, if any, from node1 to node2.  <a href="#a94d4badfc856b0d4530c37121efb9834">More...</a><br /></td></tr>
<tr class="separator:a94d4badfc856b0d4530c37121efb9834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0690edaeae8d5256189ae2e8541788b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0690edaeae8d5256189ae2e8541788b5">getArcSet</a>() const</td></tr>
<tr class="memdesc:a0690edaeae8d5256189ae2e8541788b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all arcs in the graph.  <a href="#a0690edaeae8d5256189ae2e8541788b5">More...</a><br /></td></tr>
<tr class="separator:a0690edaeae8d5256189ae2e8541788b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cfc7f4d8c738fc6f51813f50be6400"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a17cfc7f4d8c738fc6f51813f50be6400">getArcSet</a>(NodeType *node) const</td></tr>
<tr class="memdesc:a17cfc7f4d8c738fc6f51813f50be6400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all arcs that start at the specified node, indicated as a pointer to its node structure.  <a href="#a17cfc7f4d8c738fc6f51813f50be6400">More...</a><br /></td></tr>
<tr class="separator:a17cfc7f4d8c738fc6f51813f50be6400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9e2056ee2d66a7ea9feb02f016e8d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a31b9e2056ee2d66a7ea9feb02f016e8d">getArcSet</a>(string name) const</td></tr>
<tr class="memdesc:a31b9e2056ee2d66a7ea9feb02f016e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all arcs that start at the specified node.  <a href="#a31b9e2056ee2d66a7ea9feb02f016e8d">More...</a><br /></td></tr>
<tr class="separator:a31b9e2056ee2d66a7ea9feb02f016e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fd149800cd46aae497b05b46059b63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad5fd149800cd46aae497b05b46059b63">getInverseArcSet</a>(NodeType *node) const</td></tr>
<tr class="memdesc:ad5fd149800cd46aae497b05b46059b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of outbound arcs to the given node from other nodes.  <a href="#ad5fd149800cd46aae497b05b46059b63">More...</a><br /></td></tr>
<tr class="separator:ad5fd149800cd46aae497b05b46059b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfe12e71ca594736a1e329461cff024"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2cfe12e71ca594736a1e329461cff024">getInverseArcSet</a>(string name) const</td></tr>
<tr class="memdesc:a2cfe12e71ca594736a1e329461cff024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of outbound arcs to the given node from other nodes.  <a href="#a2cfe12e71ca594736a1e329461cff024">More...</a><br /></td></tr>
<tr class="separator:a2cfe12e71ca594736a1e329461cff024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eceee00e824ea4852449fa3de61e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa9eceee00e824ea4852449fa3de61e82">getInverseNeighborNames</a>(NodeType *node) const</td></tr>
<tr class="memdesc:aa9eceee00e824ea4852449fa3de61e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of strings of names of nodes that are neighbors of the given node.  <a href="#aa9eceee00e824ea4852449fa3de61e82">More...</a><br /></td></tr>
<tr class="separator:aa9eceee00e824ea4852449fa3de61e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc36bc1eb0f249180cfe78bce6e7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac3dc36bc1eb0f249180cfe78bce6e7a2">getInverseNeighborNames</a>(string node) const</td></tr>
<tr class="memdesc:ac3dc36bc1eb0f249180cfe78bce6e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of strings of names of nodes that are neighbors of the given node.  <a href="#ac3dc36bc1eb0f249180cfe78bce6e7a2">More...</a><br /></td></tr>
<tr class="separator:ac3dc36bc1eb0f249180cfe78bce6e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a5724c594b9bd0b6008c57b09af317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a80a5724c594b9bd0b6008c57b09af317">getInverseNeighbors</a>(NodeType *node) const</td></tr>
<tr class="memdesc:a80a5724c594b9bd0b6008c57b09af317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a80a5724c594b9bd0b6008c57b09af317">More...</a><br /></td></tr>
<tr class="separator:a80a5724c594b9bd0b6008c57b09af317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5294846b9cdd19394808e3736ec67004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5294846b9cdd19394808e3736ec67004">getInverseNeighbors</a>(string node) const</td></tr>
<tr class="memdesc:a5294846b9cdd19394808e3736ec67004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a5294846b9cdd19394808e3736ec67004">More...</a><br /></td></tr>
<tr class="separator:a5294846b9cdd19394808e3736ec67004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae9b5cbd2bcb3918c4c64b1eb71c1a3a8">getNeighborNames</a>(NodeType *node) const</td></tr>
<tr class="memdesc:ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of node names that are neighbors of the specified node.  <a href="#ae9b5cbd2bcb3918c4c64b1eb71c1a3a8">More...</a><br /></td></tr>
<tr class="separator:ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6175b4d672266465dd34e070c7710b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6175b4d672266465dd34e070c7710b34">getNeighborNames</a>(string node) const</td></tr>
<tr class="memdesc:a6175b4d672266465dd34e070c7710b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of node names that are neighbors of the specified node.  <a href="#a6175b4d672266465dd34e070c7710b34">More...</a><br /></td></tr>
<tr class="separator:a6175b4d672266465dd34e070c7710b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e49b167f0623a8ae76040c3e5eab3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0e49b167f0623a8ae76040c3e5eab3fb">getNeighbors</a>(NodeType *node) const</td></tr>
<tr class="memdesc:a0e49b167f0623a8ae76040c3e5eab3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a0e49b167f0623a8ae76040c3e5eab3fb">More...</a><br /></td></tr>
<tr class="separator:a0e49b167f0623a8ae76040c3e5eab3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3720906c380f36b50530419330bfe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3a3720906c380f36b50530419330bfe5">getNeighbors</a>(string node) const</td></tr>
<tr class="memdesc:a3a3720906c380f36b50530419330bfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nodes that are neighbors of the specified node.  <a href="#a3a3720906c380f36b50530419330bfe5">More...</a><br /></td></tr>
<tr class="separator:a3a3720906c380f36b50530419330bfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81487976cf0e576047333c85463c33aa"><td class="memItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a81487976cf0e576047333c85463c33aa">getNode</a>(string name) const</td></tr>
<tr class="memdesc:a81487976cf0e576047333c85463c33aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a node in the name table attached to the graph and returns a pointer to that node.  <a href="#a81487976cf0e576047333c85463c33aa">More...</a><br /></td></tr>
<tr class="separator:a81487976cf0e576047333c85463c33aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6f37932f377dd2bf4fec61343a916d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3c6f37932f377dd2bf4fec61343a916d">getNodeNames</a>() const</td></tr>
<tr class="memdesc:a3c6f37932f377dd2bf4fec61343a916d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of the names of all nodes in the graph.  <a href="#a3c6f37932f377dd2bf4fec61343a916d">More...</a><br /></td></tr>
<tr class="separator:a3c6f37932f377dd2bf4fec61343a916d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5552888f57aaa581099e8146c617c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abd5552888f57aaa581099e8146c617c9">getNodeSet</a>() const</td></tr>
<tr class="memdesc:abd5552888f57aaa581099e8146c617c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all nodes in the graph.  <a href="#abd5552888f57aaa581099e8146c617c9">More...</a><br /></td></tr>
<tr class="separator:abd5552888f57aaa581099e8146c617c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54164ab847f3a5c7fe15d15ac95af443"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a54164ab847f3a5c7fe15d15ac95af443">isConnected</a>(NodeType *n1, NodeType *n2) const</td></tr>
<tr class="memdesc:a54164ab847f3a5c7fe15d15ac95af443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>.  <a href="#a54164ab847f3a5c7fe15d15ac95af443">More...</a><br /></td></tr>
<tr class="separator:a54164ab847f3a5c7fe15d15ac95af443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3623b7decbedc522041c2c39d3b14421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3623b7decbedc522041c2c39d3b14421">isConnected</a>(string s1, string s2) const</td></tr>
<tr class="memdesc:a3623b7decbedc522041c2c39d3b14421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>.  <a href="#a3623b7decbedc522041c2c39d3b14421">More...</a><br /></td></tr>
<tr class="separator:a3623b7decbedc522041c2c39d3b14421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a>() const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the graph contains no vertexes.  <a href="#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab160bb64995133f6feb351cb23b031fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab160bb64995133f6feb351cb23b031fb">isNeighbor</a>(string node1, string node2) const</td></tr>
<tr class="memdesc:ab160bb64995133f6feb351cb23b031fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph contains an edge from v1 to v2.  <a href="#ab160bb64995133f6feb351cb23b031fb">More...</a><br /></td></tr>
<tr class="separator:ab160bb64995133f6feb351cb23b031fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e752628a118c4a06a538067c95bbb28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9e752628a118c4a06a538067c95bbb28">isNeighbor</a>(NodeType *node1, NodeType *node2) const</td></tr>
<tr class="memdesc:a9e752628a118c4a06a538067c95bbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph contains an edge from v1 to v2.  <a href="#a9e752628a118c4a06a538067c95bbb28">More...</a><br /></td></tr>
<tr class="separator:a9e752628a118c4a06a538067c95bbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd1afdb4e1c75fbe51976bf6f70c922"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5dd1afdb4e1c75fbe51976bf6f70c922">nodeCount</a>() const</td></tr>
<tr class="memdesc:a5dd1afdb4e1c75fbe51976bf6f70c922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph.  <a href="#a5dd1afdb4e1c75fbe51976bf6f70c922">More...</a><br /></td></tr>
<tr class="separator:a5dd1afdb4e1c75fbe51976bf6f70c922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd8d1cec3a4d6b8cdcb58016e4d093a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aafd8d1cec3a4d6b8cdcb58016e4d093a">operator!=</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:aafd8d1cec3a4d6b8cdcb58016e4d093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#aafd8d1cec3a4d6b8cdcb58016e4d093a">More...</a><br /></td></tr>
<tr class="separator:aafd8d1cec3a4d6b8cdcb58016e4d093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daf423faecc777e29a399812dc39ca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1daf423faecc777e29a399812dc39ca2">operator&lt;</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a1daf423faecc777e29a399812dc39ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a1daf423faecc777e29a399812dc39ca2">More...</a><br /></td></tr>
<tr class="separator:a1daf423faecc777e29a399812dc39ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352607f2b21dd87b3d2a3957bbf3da7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a352607f2b21dd87b3d2a3957bbf3da7b">operator&lt;=</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a352607f2b21dd87b3d2a3957bbf3da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a352607f2b21dd87b3d2a3957bbf3da7b">More...</a><br /></td></tr>
<tr class="separator:a352607f2b21dd87b3d2a3957bbf3da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188f85939e3fe6ed2d411f622287f722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a188f85939e3fe6ed2d411f622287f722">operator==</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a188f85939e3fe6ed2d411f622287f722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a188f85939e3fe6ed2d411f622287f722">More...</a><br /></td></tr>
<tr class="separator:a188f85939e3fe6ed2d411f622287f722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8019cf2c98949fd509193cf26ba2ff8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8019cf2c98949fd509193cf26ba2ff8a">operator&gt;</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:a8019cf2c98949fd509193cf26ba2ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#a8019cf2c98949fd509193cf26ba2ff8a">More...</a><br /></td></tr>
<tr class="separator:a8019cf2c98949fd509193cf26ba2ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ca2af20f3b0251972b72295270212e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab1ca2af20f3b0251972b72295270212e">operator&gt;=</a>(const <a class="el" href="classGraph.html">Graph</a> &amp;graph2) const</td></tr>
<tr class="memdesc:ab1ca2af20f3b0251972b72295270212e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relational operators to compare two graphs.  <a href="#ab1ca2af20f3b0251972b72295270212e">More...</a><br /></td></tr>
<tr class="separator:ab1ca2af20f3b0251972b72295270212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6370fb52d2dab4eb7795da22c33dd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af6370fb52d2dab4eb7795da22c33dd02">removeArc</a>(string s1, string s2)</td></tr>
<tr class="memdesc:af6370fb52d2dab4eb7795da22c33dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an arc from v1 to v2 in the graph, specified by the names of its endpoints.  <a href="#af6370fb52d2dab4eb7795da22c33dd02">More...</a><br /></td></tr>
<tr class="separator:af6370fb52d2dab4eb7795da22c33dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c9f44b20b49ffae9fecc0a4f156ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae0c9f44b20b49ffae9fecc0a4f156ac1">removeArc</a>(NodeType *n1, NodeType *n2)</td></tr>
<tr class="memdesc:ae0c9f44b20b49ffae9fecc0a4f156ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an arc from v1 to v2 in the graph, specified by the node pointers at its endpoints.  <a href="#ae0c9f44b20b49ffae9fecc0a4f156ac1">More...</a><br /></td></tr>
<tr class="separator:ae0c9f44b20b49ffae9fecc0a4f156ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6580d1b0228fe6c1a02dfe70de1abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9d6580d1b0228fe6c1a02dfe70de1abf">removeArc</a>(ArcType *arc)</td></tr>
<tr class="memdesc:a9d6580d1b0228fe6c1a02dfe70de1abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given arc from the graph, specified as an arc pointer.  <a href="#a9d6580d1b0228fe6c1a02dfe70de1abf">More...</a><br /></td></tr>
<tr class="separator:a9d6580d1b0228fe6c1a02dfe70de1abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f7ee89176144ed4c5c6b08a233aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2d5f7ee89176144ed4c5c6b08a233aa6">removeNode</a>(string name)</td></tr>
<tr class="memdesc:a2d5f7ee89176144ed4c5c6b08a233aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node with the given name from the graph.  <a href="#a2d5f7ee89176144ed4c5c6b08a233aa6">More...</a><br /></td></tr>
<tr class="separator:a2d5f7ee89176144ed4c5c6b08a233aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfe63019975561914e0ed79551de108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2dfe63019975561914e0ed79551de108">removeNode</a>(NodeType *node)</td></tr>
<tr class="memdesc:a2dfe63019975561914e0ed79551de108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from the graph, specified as a pointer value.  <a href="#a2dfe63019975561914e0ed79551de108">More...</a><br /></td></tr>
<tr class="separator:a2dfe63019975561914e0ed79551de108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73c985ef66569e5f6df9c315cab466b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac73c985ef66569e5f6df9c315cab466b">scanArcData</a>(<a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;, ArcType *, ArcType *)</td></tr>
<tr class="memdesc:ac73c985ef66569e5f6df9c315cab466b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the data for an arc from the scanner.  <a href="#ac73c985ef66569e5f6df9c315cab466b">More...</a><br /></td></tr>
<tr class="separator:ac73c985ef66569e5f6df9c315cab466b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e1a05a40013ce4e4bb539d05b9937"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1c4e1a05a40013ce4e4bb539d05b9937">scanGraphEntry</a>(<a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;scanner)</td></tr>
<tr class="memdesc:a1c4e1a05a40013ce4e4bb539d05b9937"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method reads one "entry" for the graph, which is either a node description or an arc description.  <a href="#a1c4e1a05a40013ce4e4bb539d05b9937">More...</a><br /></td></tr>
<tr class="separator:a1c4e1a05a40013ce4e4bb539d05b9937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc2ca3535b7bff7759aa0c1d35ff08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0fc2ca3535b7bff7759aa0c1d35ff08b">scanNodeData</a>(<a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;, NodeType *)</td></tr>
<tr class="memdesc:a0fc2ca3535b7bff7759aa0c1d35ff08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the data for the specified node from the scanner.  <a href="#a0fc2ca3535b7bff7759aa0c1d35ff08b">More...</a><br /></td></tr>
<tr class="separator:a0fc2ca3535b7bff7759aa0c1d35ff08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af9593d4a5ff4274efaf429cb4f9e57cc">size</a>() const</td></tr>
<tr class="memdesc:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph.  <a href="#af9593d4a5ff4274efaf429cb4f9e57cc">More...</a><br /></td></tr>
<tr class="separator:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1fe5121d6528fdea3f243321b3fa3a49">toString</a>() const</td></tr>
<tr class="memdesc:a1fe5121d6528fdea3f243321b3fa3a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the graph to a printable string representation.  <a href="#a1fe5121d6528fdea3f243321b3fa3a49">More...</a><br /></td></tr>
<tr class="separator:a1fe5121d6528fdea3f243321b3fa3a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ab61a83ff4792f63e9e110b534cdfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac9ab61a83ff4792f63e9e110b534cdfd">writeArcData</a>(std::ostream &amp;, ArcType *) const</td></tr>
<tr class="memdesc:ac9ab61a83ff4792f63e9e110b534cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data for the arc to the output stream.  <a href="#ac9ab61a83ff4792f63e9e110b534cdfd">More...</a><br /></td></tr>
<tr class="separator:ac9ab61a83ff4792f63e9e110b534cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0db5231476c8cb10655d58ebc108b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0db5231476c8cb10655d58ebc108b78">writeNodeData</a>(std::ostream &amp;, NodeType *) const</td></tr>
<tr class="memdesc:ac0db5231476c8cb10655d58ebc108b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the data for the node to the output stream.  <a href="#ac0db5231476c8cb10655d58ebc108b78">More...</a><br /></td></tr>
<tr class="separator:ac0db5231476c8cb10655d58ebc108b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename NodeType, typename ArcType&gt;<br />
class Graph&lt; NodeType, ArcType &gt;</h3>

<p>This class represents a graph with the specified node and arc types. </p>
<p>The <code>NodeType</code> and <code>ArcType</code> parameters indicate the structure type or class used for nodes and arcs, respectively. These types can contain any fields or methods required by the client, but must contain the following fields required by the <code><a class="el" href="classGraph.html" title="This class represents a graph with the specified node and arc types. ">Graph</a></code> package itself:</p>
<p>The <code>NodeType</code> definition must include: </p><ul>
<li>
A <code>string</code> field called <code>name</code> </li>
<li>
A <code>Set&lt;ArcType *&gt;</code> field called <code>arcs</code> </li>
</ul>
<p>The <code>ArcType</code> definition must include: </p><ul>
<li>
A <code>NodeType *</code> field called <code>start</code> </li>
<li>
A <code>NodeType *</code> field called <code>finish</code> </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a695969c31e87f9e8319d74e5ca39024b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695969c31e87f9e8319d74e5ca39024b">&#9670;&nbsp;</a></span>graph_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> =  typename <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt;NodeType *&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c40af42cad207665228815f0359bbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c40af42cad207665228815f0359bbd3">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000040">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="af5a604e5e9e4d68dbc10b312e59f678f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a604e5e9e4d68dbc10b312e59f678f">&#9670;&nbsp;</a></span>~Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classGraph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the internal storage allocated to represent the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000041">Big-Oh:</a></b></dt><dd>O(V + E) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad2e9fedd7110ae2fb6873c5e2d29941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e9fedd7110ae2fb6873c5e2d29941">&#9670;&nbsp;</a></span>addArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArcType * addArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a directed arc to the graph from node n1 to n2. </p>
<p>If either node is not found in the graph, said node will be added to the graph. Returns a pointer to the arc in case the client needs to capture this value. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000042">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a7280d3cd76bab82df392ba91ed5257c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7280d3cd76bab82df392ba91ed5257c6">&#9670;&nbsp;</a></span>addArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArcType * addArc </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a directed arc to the graph from node n1 to n2. </p>
<p>If either node is not found in the graph, said node will be added to the graph. Returns a pointer to the arc in case the client needs to capture this value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000043">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="aa1b6553e579c03260253a2d731668dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b6553e579c03260253a2d731668dfa">&#9670;&nbsp;</a></span>addArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArcType * addArc </td>
          <td>(</td>
          <td class="paramtype">ArcType *&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given arc to the graph. </p>
<p>If the start/finish nodes passed are not already part of the graph, they are added to the graph. Returns a pointer to the arc in case the client needs to capture this value.</p>
<p>Memory management: Once you hand me this ArcType* pointer, our code owns it. We will delete/free it when done with it. You do not need to (and should not) free it yourself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000044">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="acd763aa09491315536b5d2734cd82b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd763aa09491315536b5d2734cd82b89">&#9670;&nbsp;</a></span>addNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * addNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the graph. </p>
<p>The first version of this method creates a new node of the appropriate type and initializes its fields; the second assumes that the client has already created the node and simply adds it to the graph. Returns a pointer to the node. If a node with the given name is already present, does nothing.</p>
<p>Memory management: Once you hand me this NodeType* pointer, our code owns it. We will delete/free it when done with it. You do not need to (and should not) free it yourself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000045">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a635fa78d72315816cef6c091acfa3882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635fa78d72315816cef6c091acfa3882">&#9670;&nbsp;</a></span>addNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * addNode </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the graph. </p>
<p>This version assumes that the client has already created the node structure and simply adds it to the graph. Returns a pointer to the node. If a node with the given name is already present, does nothing.</p>
<p>Memory management: Once you hand me this NodeType* pointer, our code owns it. We will delete/free it when done with it. You do not need to (and should not) free it yourself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if any pointer passed is null </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000046">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="ac0b108b3354f5222d2c829dcd639fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b108b3354f5222d2c829dcd639fa7a">&#9670;&nbsp;</a></span>arcCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arcCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of arcs in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000047">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a27d59ef129bb56cc144ecc81c0affd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d59ef129bb56cc144ecc81c0affd34">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last node in the graph in the order as would be returned by a for-each loop or iterator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if the graph is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000048">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aea3a8950c46f4ac913207201b685e715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3a8950c46f4ac913207201b685e715">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an STL iterator positioned at the first vertex in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000091">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitializes the graph to be empty, removing all nodes and arcs and freeing any heap storage used by their corresponding internal structures. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000049">Big-Oh:</a></b></dt><dd>O(V + E) </dd></dl>

</div>
</div>
<a id="a63f0ce1806df1c8070d997153363eecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f0ce1806df1c8070d997153363eecb">&#9670;&nbsp;</a></span>clearArcs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearArcs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all arcs from the graph, freeing the heap storage used by their corresponding internal structures. </p>
<p>The graph's nodes remain intact. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000050">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a14def9e68896088fec7839e5da4fed27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14def9e68896088fec7839e5da4fed27">&#9670;&nbsp;</a></span>clearArcs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearArcs </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures. </p>
<p>The graph's nodes remain intact. If the given node pointer is null or not found in the graph, has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000051">Big-Oh:</a></b></dt><dd>O(log V + E) </dd></dl>

</div>
</div>
<a id="a2d8ecb9c6768fff244b2be46319385cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8ecb9c6768fff244b2be46319385cc">&#9670;&nbsp;</a></span>clearArcs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearArcs </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all arcs from the graph that start from the given node, freeing the heap storage used by their corresponding internal structures. </p>
<p>The graph's nodes remain intact. If the given node is not found in the graph, has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000052">Big-Oh:</a></b></dt><dd>O(E log E) </dd></dl>

</div>
</div>
<a id="a9ca50139471975b82fdc6b1977bcfa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca50139471975b82fdc6b1977bcfa4a">&#9670;&nbsp;</a></span>containsArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsArc </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there exists an arc directly between the given two nodes. </p>
<p>If either node is null or is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000053">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="a515e45aae316b581bf1cf168541f4f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515e45aae316b581bf1cf168541f4f44">&#9670;&nbsp;</a></span>containsArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there exists an arc directly between the given two nodes. </p>
<p>If either node is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000054">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="acf7a659ddd8a143836b91b01c200ee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7a659ddd8a143836b91b01c200ee8a">&#9670;&nbsp;</a></span>containsArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsArc </td>
          <td>(</td>
          <td class="paramtype">ArcType *&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given arc exists in this graph. </p>
<p>If the given arc is null or either of its nodes are not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000055">Big-Oh:</a></b></dt><dd>O(log E) </dd></dl>

</div>
</div>
<a id="ac0beb77e8a238c2898ab851df71eeefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0beb77e8a238c2898ab851df71eeefe">&#9670;&nbsp;</a></span>containsNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there exists a node in this graph with the given name. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000056">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a4f540ebc07c4e46a0bb7fee76a93386c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f540ebc07c4e46a0bb7fee76a93386c">&#9670;&nbsp;</a></span>containsNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool containsNode </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node is part of this graph. </p>
<p>If the pointer passed is null, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000057">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="afcdf62cae5d7e50644957d66f886742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf62cae5d7e50644957d66f886742d">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#a695969c31e87f9e8319d74e5ca39024b">graph_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an STL iterator positioned after the last vertex in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000092">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a6bec43eb3dfdf3d23eb328b406edf44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bec43eb3dfdf3d23eb328b406edf44a">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two graphs for equality. </p>
<p>Returns <code>true</code> if this graph contains exactly the same nodes, arcs, and connections as the given other graph. Identical in behavior to the == operator. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000058">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a7b7c2c1738f8e7faf84c54d7642992fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7c2c1738f8e7faf84c54d7642992fa">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first node in the graph in the order as would be returned by a for-each loop or iterator. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classErrorException.html" title="  This exception is thrown by calls to the error function. ">ErrorException</a></td><td>if the graph is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000059">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a7c33db338f839ff9e3dafe4fe61c16fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c33db338f839ff9e3dafe4fe61c16fd">&#9670;&nbsp;</a></span>getArc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArcType * getArc </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arc, if any, from node1 to node2. </p>
<p>If multiple arcs exist between the given two nodes, which is returned is unspecified. If either pointer passed is null or no such arc exists, returns a null pointer. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000060">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a94d4badfc856b0d4530c37121efb9834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d4badfc856b0d4530c37121efb9834">&#9670;&nbsp;</a></span>getArc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArcType * getArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arc, if any, from node1 to node2. </p>
<p>If multiple arcs exist between the given two nodes, which is returned is unspecified. If no such arc exists, returns a null pointer. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000061">Big-Oh:</a></b></dt><dd>O(log V + log E) </dd></dl>

</div>
</div>
<a id="a0690edaeae8d5256189ae2e8541788b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0690edaeae8d5256189ae2e8541788b5">&#9670;&nbsp;</a></span>getArcSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; &amp; getArcSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all arcs in the graph. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000062">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a17cfc7f4d8c738fc6f51813f50be6400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cfc7f4d8c738fc6f51813f50be6400">&#9670;&nbsp;</a></span>getArcSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; &amp; getArcSet </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all arcs that start at the specified node, indicated as a pointer to its node structure. </p>
<p>If the pointer passed is null or the given node is not found in the graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000063">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a31b9e2056ee2d66a7ea9feb02f016e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b9e2056ee2d66a7ea9feb02f016e8d">&#9670;&nbsp;</a></span>getArcSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; &amp; getArcSet </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all arcs that start at the specified node. </p>
<p>If the given node is not found in the graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000064">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ad5fd149800cd46aae497b05b46059b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fd149800cd46aae497b05b46059b63">&#9670;&nbsp;</a></span>getInverseArcSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; getInverseArcSet </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of outbound arcs to the given node from other nodes. </p>
<p>In other words, getInverseArcSet(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000065">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a2cfe12e71ca594736a1e329461cff024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfe12e71ca594736a1e329461cff024">&#9670;&nbsp;</a></span>getInverseArcSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; ArcType * &gt; getInverseArcSet </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of outbound arcs to the given node from other nodes. </p>
<p>In other words, getInverseArcSet(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000066">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="aa9eceee00e824ea4852449fa3de61e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eceee00e824ea4852449fa3de61e82">&#9670;&nbsp;</a></span>getInverseNeighborNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getInverseNeighborNames </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of strings of names of nodes that are neighbors of the given node. </p>
<p>In other words, getInverseNeighborNames(n1) is the set of all strings n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000067">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="ac3dc36bc1eb0f249180cfe78bce6e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dc36bc1eb0f249180cfe78bce6e7a2">&#9670;&nbsp;</a></span>getInverseNeighborNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getInverseNeighborNames </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of strings of names of nodes that are neighbors of the given node. </p>
<p>In other words, getInverseNeighborNames(n1) is the set of all strings n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000068">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a80a5724c594b9bd0b6008c57b09af317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a5724c594b9bd0b6008c57b09af317">&#9670;&nbsp;</a></span>getInverseNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt; getInverseNeighbors </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getInverseNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000069">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="a5294846b9cdd19394808e3736ec67004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5294846b9cdd19394808e3736ec67004">&#9670;&nbsp;</a></span>getInverseNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt; getInverseNeighbors </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getInverseNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n2 and ending at n1.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000070">Big-Oh:</a></b></dt><dd>O(E) </dd></dl>

</div>
</div>
<a id="ae9b5cbd2bcb3918c4c64b1eb71c1a3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5cbd2bcb3918c4c64b1eb71c1a3a8">&#9670;&nbsp;</a></span>getNeighborNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getNeighborNames </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of node names that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all strings n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000071">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a6175b4d672266465dd34e070c7710b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6175b4d672266465dd34e070c7710b34">&#9670;&nbsp;</a></span>getNeighborNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getNeighborNames </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of node names that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all strings n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000072">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a0e49b167f0623a8ae76040c3e5eab3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e49b167f0623a8ae76040c3e5eab3fb">&#9670;&nbsp;</a></span>getNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt; getNeighbors </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If any pointer passed is null, or if the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000073">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a3a3720906c380f36b50530419330bfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3720906c380f36b50530419330bfe5">&#9670;&nbsp;</a></span>getNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt; getNeighbors </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nodes that are neighbors of the specified node. </p>
<p>In other words, getNeighbors(n1) is the set of all nodes n2 such that there exists an arc E starting from n1 and ending at n2.</p>
<p>If the given node is not found in this graph, returns an empty set. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000074">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a81487976cf0e576047333c85463c33aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81487976cf0e576047333c85463c33aa">&#9670;&nbsp;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * getNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a node in the name table attached to the graph and returns a pointer to that node. </p>
<p>If no node with the specified name exists, returns <code>nullptr</code>. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000075">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a3c6f37932f377dd2bf4fec61343a916d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6f37932f377dd2bf4fec61343a916d">&#9670;&nbsp;</a></span>getNodeNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; string &gt; getNodeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of the names of all nodes in the graph. </p>
<p>Similar to getNodeSet but returns a set of strings rather than a set of pointers to nodes. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000076">Big-Oh:</a></b></dt><dd>O(V log V) </dd></dl>

</div>
</div>
<a id="abd5552888f57aaa581099e8146c617c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5552888f57aaa581099e8146c617c9">&#9670;&nbsp;</a></span>getNodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstanfordcpplib_1_1collections_1_1GenericSet.html">Set</a>&lt; NodeType * &gt; &amp; getNodeSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of all nodes in the graph. </p>
<p>These are direct pointers to the internal NodeType* structures in the graph, so any modifications you make to them will be reflected in the graph. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000077">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a54164ab847f3a5c7fe15d15ac95af443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54164ab847f3a5c7fe15d15ac95af443">&#9670;&nbsp;</a></span>isConnected() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnected </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>. </p>
<p>If any pointer passed is null, or if either node is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000078">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a3623b7decbedc522041c2c39d3b14421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3623b7decbedc522041c2c39d3b14421">&#9670;&nbsp;</a></span>isConnected() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnected </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the graph contains an arc from <code>n1</code> to <code>n2</code>. </p>
<p>If either node is not contained in this graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000079">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the graph contains no vertexes. </p>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000082">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="ab160bb64995133f6feb351cb23b031fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab160bb64995133f6feb351cb23b031fb">&#9670;&nbsp;</a></span>isNeighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isNeighbor </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph contains an edge from v1 to v2. </p>
<p>If either of the vertexes supplied is not found in the graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000080">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a9e752628a118c4a06a538067c95bbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e752628a118c4a06a538067c95bbb28">&#9670;&nbsp;</a></span>isNeighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isNeighbor </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph contains an edge from v1 to v2. </p>
<p>If either of the vertexes supplied is null or is not found in the graph, returns false. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000081">Big-Oh:</a></b></dt><dd>O(log V) </dd></dl>

</div>
</div>
<a id="a5dd1afdb4e1c75fbe51976bf6f70c922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd1afdb4e1c75fbe51976bf6f70c922">&#9670;&nbsp;</a></span>nodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes in the graph. </p>
<p>Equivalent to <a class="el" href="classGraph.html#af9593d4a5ff4274efaf429cb4f9e57cc" title="Returns the number of nodes in the graph. ">size()</a>. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000083">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="aafd8d1cec3a4d6b8cdcb58016e4d093a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd8d1cec3a4d6b8cdcb58016e4d093a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The ==, != operators require that the ValueType has a == operator so that the elements can be tested for equality. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000094">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a1daf423faecc777e29a399812dc39ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1daf423faecc777e29a399812dc39ca2">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000095">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a352607f2b21dd87b3d2a3957bbf3da7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352607f2b21dd87b3d2a3957bbf3da7b">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000096">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a188f85939e3fe6ed2d411f622287f722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188f85939e3fe6ed2d411f622287f722">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The ==, != operators require that the ValueType has a == operator so that the elements can be tested for equality. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000093">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="a8019cf2c98949fd509193cf26ba2ff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8019cf2c98949fd509193cf26ba2ff8a">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000097">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="ab1ca2af20f3b0251972b72295270212e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ca2af20f3b0251972b72295270212e">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraph.html">Graph</a>&lt; NodeType, ArcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relational operators to compare two graphs. </p>
<p>The &lt;, &gt;, &lt;=, &gt;= operators require that the ValueType has a &lt; operator so that the elements can be compared pairwise. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000098">Big-Oh:</a></b></dt><dd>O(V log V + E log E) </dd></dl>

</div>
</div>
<a id="af6370fb52d2dab4eb7795da22c33dd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6370fb52d2dab4eb7795da22c33dd02">&#9670;&nbsp;</a></span>removeArc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeArc </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an arc from v1 to v2 in the graph, specified by the names of its endpoints. </p>
<p>If more than one arc connects the specified endpoints, all of them are removed. If no arc connects the given endpoints, or the given arc is not found, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000084">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="ae0c9f44b20b49ffae9fecc0a4f156ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c9f44b20b49ffae9fecc0a4f156ac1">&#9670;&nbsp;</a></span>removeArc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeArc </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an arc from v1 to v2 in the graph, specified by the node pointers at its endpoints. </p>
<p>If more than one arc connects the specified endpoints, all of them are removed. If no arc connects the given endpoints, or the given arc is not found, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000085">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a9d6580d1b0228fe6c1a02dfe70de1abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6580d1b0228fe6c1a02dfe70de1abf">&#9670;&nbsp;</a></span>removeArc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeArc </td>
          <td>(</td>
          <td class="paramtype">ArcType *&#160;</td>
          <td class="paramname"><em>arc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given arc from the graph, specified as an arc pointer. </p>
<p>If more than one arc connects the specified endpoints, all of them are removed. If no arc connects the given endpoints, or the given arc is not found, the call has no effect.</p>
<p>Memory management: Our code will delete/free the ArcType* object when done with it. You do not need to (and should not) free it yourself. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000086">Big-Oh:</a></b></dt><dd>O(log E + log V) </dd></dl>

</div>
</div>
<a id="a2d5f7ee89176144ed4c5c6b08a233aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5f7ee89176144ed4c5c6b08a233aa6">&#9670;&nbsp;</a></span>removeNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeNode </td>
          <td>(</td>
          <td class="paramtype">string &#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the node with the given name from the graph. </p>
<p>Removing a node also removes all arcs that contain that node. If a node name is passed that is not part of the graph, the call has no effect. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000087">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="a2dfe63019975561914e0ed79551de108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfe63019975561914e0ed79551de108">&#9670;&nbsp;</a></span>removeNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeNode </td>
          <td>(</td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a node from the graph, specified as a pointer value. </p>
<p>Removing a node also removes all arcs that contain that node. If a node or name is passed that is null or is not part of the graph, the call has no effect.</p>
<p>Memory management: Our code will delete/free the NodeType* object when done with it. You do not need to (and should not) free it yourself. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000088">Big-Oh:</a></b></dt><dd>O(E + log V) </dd></dl>

</div>
</div>
<a id="ac73c985ef66569e5f6df9c315cab466b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73c985ef66569e5f6df9c315cab466b">&#9670;&nbsp;</a></span>scanArcData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void scanArcData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArcType *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArcType *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the data for an arc from the scanner. </p>
<p>The <code>forward</code> argument points to the arc in the forward direction. If the arc is undirected, <code>backward</code> points to the reverse arc; for directed arcs, the <code>backward</code> pointer is <code>nullptr</code>.</p>
<p>The default implementation of this method is empty. Clients that want to initialize other fields in the arc must override this method so that it initializes one or both arc, as appropriate. </p>

<p>Reimplemented in <a class="el" href="classBasicGraphGen.html#a4314b3b6bda0755a87e49070edd17c3d">BasicGraphGen&lt; V, E &gt;</a>.</p>

</div>
</div>
<a id="a1c4e1a05a40013ce4e4bb539d05b9937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4e1a05a40013ce4e4bb539d05b9937">&#9670;&nbsp;</a></span>scanGraphEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool scanGraphEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;&#160;</td>
          <td class="paramname"><em>scanner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method reads one "entry" for the graph, which is either a node description or an arc description. </p>
<p>The <code>scanGraphEntry</code> method returns <code>true</code> if it reads an entry, and <code>false</code> at the end of file or at text that cannot be recognized as a graph entry.</p>
<p>Node entries consist of the name of a node (which may be quoted if it contains special characters), optionally followed by data for the node. Arc descriptions have one of the following forms:</p>
<pre>
n1 -&gt; n2
n1 - n2
</pre><p>either of which can be followed by data for the arc. The first form creates a single directed arc; the second creates two arcs, one in each direction.</p>
<p>Clients who want to read node or arc data must override the empty versions of <code>scanNodeData</code> and <code>scanArcData</code> included in this interface. </p>

</div>
</div>
<a id="a0fc2ca3535b7bff7759aa0c1d35ff08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc2ca3535b7bff7759aa0c1d35ff08b">&#9670;&nbsp;</a></span>scanNodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void scanNodeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTokenScanner.html">TokenScanner</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the data for the specified node from the scanner. </p>
<p>The default implementation of this method is empty. Clients that want to initialize other fields in the node from the token stream must override this method. </p>

</div>
</div>
<a id="af9593d4a5ff4274efaf429cb4f9e57cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9593d4a5ff4274efaf429cb4f9e57cc">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of nodes in the graph. </p>
<p>Equivalent to nodeCount. </p><dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000089">Big-Oh:</a></b></dt><dd>O(1) </dd></dl>

</div>
</div>
<a id="a1fe5121d6528fdea3f243321b3fa3a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5121d6528fdea3f243321b3fa3a49">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the graph to a printable string representation. </p>
<dl class="section return"><dt>Returns</dt><dd>a string such as <code>"{A, B, C, D, A - B, B - D, C - D}"</code>. </dd></dl>
<dl class="BigOh"><dt><b><a class="el" href="BigOh.html#_BigOh000090">Big-Oh:</a></b></dt><dd>O(V + E) </dd></dl>

</div>
</div>
<a id="ac9ab61a83ff4792f63e9e110b534cdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ab61a83ff4792f63e9e110b534cdfd">&#9670;&nbsp;</a></span>writeArcData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void writeArcData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArcType *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the data for the arc to the output stream. </p>
<p>The default implementation of this method is empty. Clients that want to store other fields from the arc must override this method so that it writes that data in a form that scanArcData can read. </p>

<p>Reimplemented in <a class="el" href="classBasicGraphGen.html#ae7be688f4ddbd7da8eb2a8c7eef8901c">BasicGraphGen&lt; V, E &gt;</a>.</p>

</div>
</div>
<a id="ac0db5231476c8cb10655d58ebc108b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0db5231476c8cb10655d58ebc108b78">&#9670;&nbsp;</a></span>writeNodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void writeNodeData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeType *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the data for the node to the output stream. </p>
<p>The default implementation of this method is empty. Clients that want to store other fields from the node must override this method so that it writes that data in a form that scanNodeData can read. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
