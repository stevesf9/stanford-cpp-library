\hypertarget{classManaged}{}\section{Managed$<$ T $>$ Class Template Reference}
\label{classManaged}\index{Managed$<$ T $>$@{Managed$<$ T $>$}}


The \mbox{\hyperlink{classManaged}{Managed}} template class can be used to define classes that perform checks on how their objects are allocated.  




{\ttfamily \#include $<$managed.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classManaged_a86107594327f3a001230df9802cd4422}{operator delete}} (void $\ast$p)
\begin{DoxyCompactList}\small\item\em Overloaded delete operator tracks what pointers were deleted and can print errors if the client, for example, tries to delete the same pointer twice by mistake. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{classManaged_a94f5168cf29183b0ae2ea3a3731c317a}{operator new}} (size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Overloaded new operator tracks heap memory allocated to newly created objects. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classManaged_a0be75425cb8e4ae478e48c46fccc4b69}{Managed}} ()
\begin{DoxyCompactList}\small\item\em Constructor that logs the construction of this object for later use. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static int \mbox{\hyperlink{classManaged_add9e9d39e8a6f6ee972898d928b65ad3}{get\+Delete\+Count}} ()
\begin{DoxyCompactList}\small\item\em Returns the total number of objects of this type that have been deleted. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{classManaged_ae7adc08acbd8f6db8e7b98ad0709d9f4}{get\+Instance\+Count}} ()
\begin{DoxyCompactList}\small\item\em Returns the total number of objects of this type that have been created. \end{DoxyCompactList}\item 
static int \mbox{\hyperlink{classManaged_ad6fcbfd737c828fe9a7ed1a5008a2d56}{get\+Leak\+Count}} ()
\begin{DoxyCompactList}\small\item\em Returns the total number of objects of this type that seem to be memory leaks (the number of objects created minus the number deleted). \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{classManaged_a0f7c4d11f087bd2ca4b2499e163b6285}{has\+Memory\+Leak}} ()
\begin{DoxyCompactList}\small\item\em Returns true if this type has a probable memory leak (seems to have some objects that have been created but not freed). \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_a8c9fc6e457eee241a98aa675a241642a}{notify\+Of\+Construction}} (void $\ast$const p)
\begin{DoxyCompactList}\small\item\em Called when a new object is constructed. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_a5077633649d2c853d0b800e0722da369}{notify\+Of\+Delete}} (T $\ast$const)
\begin{DoxyCompactList}\small\item\em Called when an object is deleted. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_a0c190bc9c1baf9176a72b63e3ba0d985}{reset\+Instance\+And\+Free\+Counts}} ()
\begin{DoxyCompactList}\small\item\em Sets the numbers of objects created and deleted back to zero. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_a63f381f9b36ca3cfb6ff93de9deb8d4c}{set\+Heap\+Allocation\+Allowed}} (bool allowed=true)
\begin{DoxyCompactList}\small\item\em Sets whether this type allows its objects to be allocated on the heap. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_a51650b1dc51e20f1c7e846883a0d9467}{set\+Heap\+Allocation\+Without\+New\+Allowed}} (bool allowed=true)
\begin{DoxyCompactList}\small\item\em Sets whether this type allows its objects to be allocated on the heap but without the use of the \textquotesingle{}new\textquotesingle{} operator. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_aafc988bee6bf29534c249cf50b6107fc}{set\+Stack\+Allocation\+Allowed}} (bool allowed)
\begin{DoxyCompactList}\small\item\em Sets whether this type allows its objects to be allocated on the stack, such as local variables declared in functions. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{classManaged_a0322175a93f8a3246e9ef1ade5718493}{set\+Static\+Allocation\+Allowed}} (bool allowed)
\begin{DoxyCompactList}\small\item\em Sets whether this type allows its objects to be allocated in static storage, such as static variables declared in functions. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class Managed$<$ T $>$}

The \mbox{\hyperlink{classManaged}{Managed}} template class can be used to define classes that perform checks on how their objects are allocated. 

For example, in a \mbox{\hyperlink{classManaged}{Managed}} subclass you can forbid objects from being allocated on the stack 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classManaged_a0be75425cb8e4ae478e48c46fccc4b69}\label{classManaged_a0be75425cb8e4ae478e48c46fccc4b69}} 
\index{Managed@{Managed}!Managed@{Managed}}
\index{Managed@{Managed}!Managed@{Managed}}
\subsubsection{\texorpdfstring{Managed()}{Managed()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classManaged}{Managed}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Constructor that logs the construction of this object for later use. 



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classManaged_add9e9d39e8a6f6ee972898d928b65ad3}\label{classManaged_add9e9d39e8a6f6ee972898d928b65ad3}} 
\index{Managed@{Managed}!get\+Delete\+Count@{get\+Delete\+Count}}
\index{get\+Delete\+Count@{get\+Delete\+Count}!Managed@{Managed}}
\subsubsection{\texorpdfstring{get\+Delete\+Count()}{getDeleteCount()}}
{\footnotesize\ttfamily static int get\+Delete\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Returns the total number of objects of this type that have been deleted. 

\mbox{\Hypertarget{classManaged_ae7adc08acbd8f6db8e7b98ad0709d9f4}\label{classManaged_ae7adc08acbd8f6db8e7b98ad0709d9f4}} 
\index{Managed@{Managed}!get\+Instance\+Count@{get\+Instance\+Count}}
\index{get\+Instance\+Count@{get\+Instance\+Count}!Managed@{Managed}}
\subsubsection{\texorpdfstring{get\+Instance\+Count()}{getInstanceCount()}}
{\footnotesize\ttfamily static int get\+Instance\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Returns the total number of objects of this type that have been created. 

\mbox{\Hypertarget{classManaged_ad6fcbfd737c828fe9a7ed1a5008a2d56}\label{classManaged_ad6fcbfd737c828fe9a7ed1a5008a2d56}} 
\index{Managed@{Managed}!get\+Leak\+Count@{get\+Leak\+Count}}
\index{get\+Leak\+Count@{get\+Leak\+Count}!Managed@{Managed}}
\subsubsection{\texorpdfstring{get\+Leak\+Count()}{getLeakCount()}}
{\footnotesize\ttfamily static int get\+Leak\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Returns the total number of objects of this type that seem to be memory leaks (the number of objects created minus the number deleted). 

\mbox{\Hypertarget{classManaged_a0f7c4d11f087bd2ca4b2499e163b6285}\label{classManaged_a0f7c4d11f087bd2ca4b2499e163b6285}} 
\index{Managed@{Managed}!has\+Memory\+Leak@{has\+Memory\+Leak}}
\index{has\+Memory\+Leak@{has\+Memory\+Leak}!Managed@{Managed}}
\subsubsection{\texorpdfstring{has\+Memory\+Leak()}{hasMemoryLeak()}}
{\footnotesize\ttfamily static bool has\+Memory\+Leak (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Returns true if this type has a probable memory leak (seems to have some objects that have been created but not freed). 

\mbox{\Hypertarget{classManaged_a8c9fc6e457eee241a98aa675a241642a}\label{classManaged_a8c9fc6e457eee241a98aa675a241642a}} 
\index{Managed@{Managed}!notify\+Of\+Construction@{notify\+Of\+Construction}}
\index{notify\+Of\+Construction@{notify\+Of\+Construction}!Managed@{Managed}}
\subsubsection{\texorpdfstring{notify\+Of\+Construction()}{notifyOfConstruction()}}
{\footnotesize\ttfamily static void notify\+Of\+Construction (\begin{DoxyParamCaption}\item[{void $\ast$const}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Called when a new object is constructed. 


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{classErrorException}{Error\+Exception}}} & if this object is created in an illegal way. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{classManaged_a5077633649d2c853d0b800e0722da369}\label{classManaged_a5077633649d2c853d0b800e0722da369}} 
\index{Managed@{Managed}!notify\+Of\+Delete@{notify\+Of\+Delete}}
\index{notify\+Of\+Delete@{notify\+Of\+Delete}!Managed@{Managed}}
\subsubsection{\texorpdfstring{notify\+Of\+Delete()}{notifyOfDelete()}}
{\footnotesize\ttfamily static void notify\+Of\+Delete (\begin{DoxyParamCaption}\item[{T $\ast$}]{const }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Called when an object is deleted. 

\mbox{\Hypertarget{classManaged_a86107594327f3a001230df9802cd4422}\label{classManaged_a86107594327f3a001230df9802cd4422}} 
\index{Managed@{Managed}!operator delete@{operator delete}}
\index{operator delete@{operator delete}!Managed@{Managed}}
\subsubsection{\texorpdfstring{operator delete()}{operator delete()}}
{\footnotesize\ttfamily void operator delete (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Overloaded delete operator tracks what pointers were deleted and can print errors if the client, for example, tries to delete the same pointer twice by mistake. 

\mbox{\Hypertarget{classManaged_a94f5168cf29183b0ae2ea3a3731c317a}\label{classManaged_a94f5168cf29183b0ae2ea3a3731c317a}} 
\index{Managed@{Managed}!operator new@{operator new}}
\index{operator new@{operator new}!Managed@{Managed}}
\subsubsection{\texorpdfstring{operator new()}{operator new()}}
{\footnotesize\ttfamily void$\ast$ operator new (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Overloaded new operator tracks heap memory allocated to newly created objects. 

\mbox{\Hypertarget{classManaged_a0c190bc9c1baf9176a72b63e3ba0d985}\label{classManaged_a0c190bc9c1baf9176a72b63e3ba0d985}} 
\index{Managed@{Managed}!reset\+Instance\+And\+Free\+Counts@{reset\+Instance\+And\+Free\+Counts}}
\index{reset\+Instance\+And\+Free\+Counts@{reset\+Instance\+And\+Free\+Counts}!Managed@{Managed}}
\subsubsection{\texorpdfstring{reset\+Instance\+And\+Free\+Counts()}{resetInstanceAndFreeCounts()}}
{\footnotesize\ttfamily static void reset\+Instance\+And\+Free\+Counts (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Sets the numbers of objects created and deleted back to zero. 

This would be used by autograder programs between leak tests. \mbox{\Hypertarget{classManaged_a63f381f9b36ca3cfb6ff93de9deb8d4c}\label{classManaged_a63f381f9b36ca3cfb6ff93de9deb8d4c}} 
\index{Managed@{Managed}!set\+Heap\+Allocation\+Allowed@{set\+Heap\+Allocation\+Allowed}}
\index{set\+Heap\+Allocation\+Allowed@{set\+Heap\+Allocation\+Allowed}!Managed@{Managed}}
\subsubsection{\texorpdfstring{set\+Heap\+Allocation\+Allowed()}{setHeapAllocationAllowed()}}
{\footnotesize\ttfamily static void set\+Heap\+Allocation\+Allowed (\begin{DoxyParamCaption}\item[{bool}]{allowed = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Sets whether this type allows its objects to be allocated on the heap. 

Default true. \mbox{\Hypertarget{classManaged_a51650b1dc51e20f1c7e846883a0d9467}\label{classManaged_a51650b1dc51e20f1c7e846883a0d9467}} 
\index{Managed@{Managed}!set\+Heap\+Allocation\+Without\+New\+Allowed@{set\+Heap\+Allocation\+Without\+New\+Allowed}}
\index{set\+Heap\+Allocation\+Without\+New\+Allowed@{set\+Heap\+Allocation\+Without\+New\+Allowed}!Managed@{Managed}}
\subsubsection{\texorpdfstring{set\+Heap\+Allocation\+Without\+New\+Allowed()}{setHeapAllocationWithoutNewAllowed()}}
{\footnotesize\ttfamily static void set\+Heap\+Allocation\+Without\+New\+Allowed (\begin{DoxyParamCaption}\item[{bool}]{allowed = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Sets whether this type allows its objects to be allocated on the heap but without the use of the \textquotesingle{}new\textquotesingle{} operator. 

This is to handle the subtle case of an outer object containing this object, where the outer object is heap-\/allocated but the inner object is declared as an object rather than as a pointer. Setting this to false ensures that all uses of this class must be done via pointers and new rather than declaring objects directly. Default true. \mbox{\Hypertarget{classManaged_aafc988bee6bf29534c249cf50b6107fc}\label{classManaged_aafc988bee6bf29534c249cf50b6107fc}} 
\index{Managed@{Managed}!set\+Stack\+Allocation\+Allowed@{set\+Stack\+Allocation\+Allowed}}
\index{set\+Stack\+Allocation\+Allowed@{set\+Stack\+Allocation\+Allowed}!Managed@{Managed}}
\subsubsection{\texorpdfstring{set\+Stack\+Allocation\+Allowed()}{setStackAllocationAllowed()}}
{\footnotesize\ttfamily static void set\+Stack\+Allocation\+Allowed (\begin{DoxyParamCaption}\item[{bool}]{allowed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Sets whether this type allows its objects to be allocated on the stack, such as local variables declared in functions. 

\mbox{\Hypertarget{classManaged_a0322175a93f8a3246e9ef1ade5718493}\label{classManaged_a0322175a93f8a3246e9ef1ade5718493}} 
\index{Managed@{Managed}!set\+Static\+Allocation\+Allowed@{set\+Static\+Allocation\+Allowed}}
\index{set\+Static\+Allocation\+Allowed@{set\+Static\+Allocation\+Allowed}!Managed@{Managed}}
\subsubsection{\texorpdfstring{set\+Static\+Allocation\+Allowed()}{setStaticAllocationAllowed()}}
{\footnotesize\ttfamily static void set\+Static\+Allocation\+Allowed (\begin{DoxyParamCaption}\item[{bool}]{allowed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [protected]}}



Sets whether this type allows its objects to be allocated in static storage, such as static variables declared in functions. 

