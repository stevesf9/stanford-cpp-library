\hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet}{}\section{Generic\+Set$<$ Set\+Traits $>$ Class Template Reference}
\label{classstanfordcpplib_1_1collections_1_1GenericSet}\index{Generic\+Set$<$ Set\+Traits $>$@{Generic\+Set$<$ Set\+Traits $>$}}


\subsubsection*{Class\+: Generic\+Set$<$\+Set\+Traits$>$ }

This class stores a collection of distinct elements.  




{\ttfamily \#include $<$collections.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a49eb513fe04e245250a4aebfb1ac768a}{const\+\_\+iterator}} = typename \mbox{\hyperlink{classMap_a04e3b848cce2bbfed5ea818e1b264000}{Set\+Traits\+::\+Map\+Type\+::const\+\_\+iterator}}
\item 
using \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}{iterator}} = \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a49eb513fe04e245250a4aebfb1ac768a}{const\+\_\+iterator}}
\item 
using \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} = typename \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits_aecaeabaa9da616ae42bb20787878260d}{Set\+Traits\+::\+Value\+Type}}
\begin{DoxyCompactList}\small\item\em Utility alias to make things easier to work with. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a509ac9cd7429d3187594beced88d4921}{Generic\+Set}} ()=default
\begin{DoxyCompactList}\small\item\em Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \subsubsection*{Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set; }

Initializes an empty set of the specified element type. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a6bac19c4194012a2724702caf3a15e20}{Generic\+Set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} $>$ list)
\begin{DoxyCompactList}\small\item\em Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \subsubsection*{Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set \{1, 2, 3\}; }

Initializes a new set that stores the given elements. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_abcd375e42dcb08298b04d3425d2b95d7}{Generic\+Set}} (Args... args)
\begin{DoxyCompactList}\small\item\em Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set(... \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_aae5f987c2f3dc9708bed63dd9c80b5fa}{Generic\+Set}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} $>$ list, Args... args)
\begin{DoxyCompactList}\small\item\em Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set(\{1, 2, 3\}, ... \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab221b36dcc150632e4f355130d16f377}{$\sim$\+Generic\+Set}} ()=default
\begin{DoxyCompactList}\small\item\em \subsubsection*{Destructor\+: $\sim$\+Set }

Frees any heap storage associated with this set. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a7cfcf4823a6ebadb0244d0943e5ea727}{add}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Method\+: add \subsubsection*{Usage\+: set.\+add(value); }

Adds an element to this set, if it was not already there. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ad7f4cd8986fd068b79d2a69a79348a7e}{add\+All}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set)
\begin{DoxyCompactList}\small\item\em Method\+: add\+All \subsubsection*{Usage\+: set.\+add\+All(set2); }

Adds all elements of the given other set to this set. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a4b351b4cfc065bb0eee5d8c7404c3147}{back}} () const
\begin{DoxyCompactList}\small\item\em Method\+: back \subsubsection*{Usage\+: Value\+Type value = set.\+back(); }

Returns the last value in the set in the order established by the {\ttfamily foreach} macro. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}{iterator}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a0c62c15c8ed609e7e5e9518cf5f5c712}{begin}} () const
\item 
void \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ac8bb3912a3ce86b15842e79d0b421204}{clear}} ()
\begin{DoxyCompactList}\small\item\em Method\+: clear \subsubsection*{Usage\+: set.\+clear(); }

Removes all elements from this set. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a9b67116c496b2347931664ac27c37921}{contains}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value) const
\begin{DoxyCompactList}\small\item\em Method\+: contains Usage\+: if (set.\+contains(value)) ... \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_abaa27e9ac99d4d889625d3989b40f0b6}{contains\+All}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Method\+: contains\+All Usage\+: if (set.\+contains\+All(set2)) ... \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_af6112917491bf7803154d808ad93518d}{difference}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set)
\begin{DoxyCompactList}\small\item\em Method\+: difference \subsubsection*{Usage\+: set.\+difference(set2); }

Removes all elements of the given other set from this set. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}{iterator}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a68b688a51bd0cf6fb5bc2cba292209a8}{end}} () const
\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_af0f6c12b7eb171e7b5e3725f04f3c1f3}{equals}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Method\+: equals Usage\+: if (set.\+equals(set2)) ... \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a645a432ab2e8069945e37c3adc9a7ff5}{first}} () const
\begin{DoxyCompactList}\small\item\em Method\+: first \subsubsection*{Usage\+: Value\+Type value = set.\+first(); }

Returns the first value in the set in the order established by the {\ttfamily foreach} macro. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a9c9f0cc6419ef7e036df4eeac4825b2c}{front}} () const
\begin{DoxyCompactList}\small\item\em Method\+: front \subsubsection*{Usage\+: Value\+Type value = set.\+front(); }

Returns the first value in the set in the order established by the {\ttfamily foreach} macro. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_aa81ff41776176f38b1a5c616f1815831}{insert}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Method\+: insert \subsubsection*{Usage\+: set.\+insert(value); }

Adds an element to this set, if it was not already there. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a1892695645d8f29cbc6c8587500f2829}{intersect}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set)
\begin{DoxyCompactList}\small\item\em Method\+: intersect \subsubsection*{Usage\+: set.\+intersect(set2); }

Removes all elements from this set that are not contained in the given other set. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_acf82f9b2937375c7b1cf3dccb3df3312}{is\+Empty}} () const
\begin{DoxyCompactList}\small\item\em Method\+: is\+Empty Usage\+: if (set.\+is\+Empty()) ... \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_af8ce41f03d31f89935db1f3f5fdffc2c}{is\+Subset\+Of}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Method\+: is\+Subset\+Of Usage\+: if (set.\+is\+Subset\+Of(set2)) ... \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a074ab19fab73dfcff220d4b64aa5be82}{is\+Superset\+Of}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Method\+: is\+Superset\+Of Usage\+: if (set.\+is\+Superset\+Of(set2)) ... \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_af2ca00030776c68af16559092a3856a4}{map\+All}} (std\+::function$<$ void(const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&)$>$ fn) const
\begin{DoxyCompactList}\small\item\em Method\+: map\+All \subsubsection*{Usage\+: set.\+map\+All(fn); }

Iterates through the elements of the set and calls {\ttfamily fn(value)} for each one. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a2da26ab6a8320bed56ef83210a0addf8}{operator!=}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Operator\+: != \subsubsection*{Usage\+: set1 != set2 }

Returns {\ttfamily true} if {\ttfamily set1} and {\ttfamily set2} are different. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a834d22cfc42c67b0243283c3bc02ce5e}{operator$\ast$}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Operator\+: $\ast$ \subsubsection*{Usage\+: set1 $\ast$ set2 }

Returns the intersection of sets {\ttfamily set1} and {\ttfamily set2}, which is the set of all elements that appear in both. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a1528986f737cd2163e1361e0bf326957}{operator$\ast$=}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2)
\begin{DoxyCompactList}\small\item\em Operator\+: $\ast$= \subsubsection*{Usage\+: set1 $\ast$= set2; }

Removes any elements from {\ttfamily set1} that are not present in {\ttfamily set2}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_afea3af6c9d038b2965e152623d790723}{operator+}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Operator\+: + Usage\+: set1 + set2 \subsubsection*{set1 + element }

Returns the union of sets {\ttfamily set1} and {\ttfamily set2}, which is the set of elements that appear in at least one of the two sets. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_afa15583f3e2d538799d56f6ac04608b9}{operator+}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&element) const
\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_af79734e82170dc5c5c9304a9d1898d57}{operator+=}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2)
\begin{DoxyCompactList}\small\item\em ~\newline
 Operator\+: += Usage\+: set1 += set2; \subsubsection*{set1 += value; }

Adds all of the elements from {\ttfamily set2} (or the single specified value) to {\ttfamily set1}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a47b0925fd317fb30201e28139c7370e5}{operator+=}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value)
\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ad2860c6b9af5560b816dd9f10dc13f27}{operator,}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value)
\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a5996e7e22f84d81f44c2402c2493d43b}{operator-\/}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Operator\+: -\/ Usage\+: set1 -\/ set2 \subsubsection*{set1 -\/ element }

Returns the difference of sets {\ttfamily set1} and {\ttfamily set2}, which is all of the elements that appear in {\ttfamily set1} but not {\ttfamily set2}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a4c09cbefc6834fc9010e209c8ce90765}{operator-\/}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&element) const
\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_adffcff306f0a21b87fc0eb99343a2719}{operator-\/=}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2)
\begin{DoxyCompactList}\small\item\em ~\newline
 Operator\+: -\/= Usage\+: set1 -\/= set2; \subsubsection*{set1 -\/= value; }

Removes the elements from {\ttfamily set2} (or the single specified value) from {\ttfamily set1}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a6c4b3d414008341cbea6e24f14a2ee11}{operator-\/=}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value)
\item 
bool \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a7f956a22921c1683b74783b055bbb2b5}{operator==}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set2) const
\begin{DoxyCompactList}\small\item\em Operator\+: == \subsubsection*{Usage\+: set1 == set2 }

Returns {\ttfamily true} if {\ttfamily set1} and {\ttfamily set2} contain the same elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab522af639e5f45b032943bc611de79db}{remove}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&value)
\begin{DoxyCompactList}\small\item\em Method\+: remove \subsubsection*{Usage\+: set.\+remove(value); }

Removes an element from this set. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a59fc29f868cd2ce2668788198e8a05a7}{remove\+All}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set)
\begin{DoxyCompactList}\small\item\em Method\+: remove\+All \subsubsection*{Usage\+: set.\+remove\+All(set2); }

Removes all elements of the given other set from this set. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a15b39be914ac3e2ecb6f0d14ab893f9a}{retain\+All}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set)
\begin{DoxyCompactList}\small\item\em Method\+: retain\+All \subsubsection*{Usage\+: set.\+retain\+All(set2); }

Removes all elements from this set that are not contained in the given other set. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_af9593d4a5ff4274efaf429cb4f9e57cc}{size}} () const
\begin{DoxyCompactList}\small\item\em Method\+: size \subsubsection*{Usage\+: count = set.\+size(); }

Returns the number of elements in this set. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a1fe5121d6528fdea3f243321b3fa3a49}{to\+String}} () const
\begin{DoxyCompactList}\small\item\em Method\+: to\+String \subsubsection*{Usage\+: string str = set.\+to\+String(); }

Converts the set to a printable string representation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \& \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_affa3b4d177e1794dbb3e6a414a5ec2b3}{union\+With}} (const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \&set)
\begin{DoxyCompactList}\small\item\em Method\+: union\+With \subsubsection*{Usage\+: set.\+union\+With(set2); }

Adds all elements of the given other set to this set. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Set\+Traits$>$\newline
class stanfordcpplib\+::collections\+::\+Generic\+Set$<$ Set\+Traits $>$}

\subsubsection*{Class\+: Generic\+Set$<$\+Set\+Traits$>$ }

This class stores a collection of distinct elements. 

\mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} should be a type containing the following\+: \begin{DoxyVerb}typename ValueType:          whatever is stored in the map
typename MapType:            should be a Map<ValueType, bool>
static std::string name():   should return the name of the type.
\end{DoxyVerb}


There\textquotesingle{}s one more requirement\+: you need to define a function \begin{DoxyVerb}template <typename... Args>
   static MapType construct(Args&&... args)
\end{DoxyVerb}


that constructs an internal Map\+Type object with the specified arguments. This function should do something creative or clever to ensure that there is a nice compiler error generated in the event that the arguments are invalid, since otherwise the error is going to be deeply nested inside the \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} template.

This is not meant to be used directly by students. 

\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a49eb513fe04e245250a4aebfb1ac768a}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a49eb513fe04e245250a4aebfb1ac768a}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!const\+\_\+iterator@{const\+\_\+iterator}}
\index{const\+\_\+iterator@{const\+\_\+iterator}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{const\+\_\+iterator}{const\_iterator}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a49eb513fe04e245250a4aebfb1ac768a}{const\+\_\+iterator}} =  typename \mbox{\hyperlink{classMap_a04e3b848cce2bbfed5ea818e1b264000}{Set\+Traits\+::\+Map\+Type\+::const\+\_\+iterator}}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!iterator@{iterator}}
\index{iterator@{iterator}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{iterator}{iterator}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}{iterator}} =  \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a49eb513fe04e245250a4aebfb1ac768a}{const\+\_\+iterator}}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!value\+\_\+type@{value\+\_\+type}}
\index{value\+\_\+type@{value\+\_\+type}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{value\+\_\+type}{value\_type}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} =  typename \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits_aecaeabaa9da616ae42bb20787878260d}{Set\+Traits\+::\+Value\+Type}}}



Utility alias to make things easier to work with. 



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a509ac9cd7429d3187594beced88d4921}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a509ac9cd7429d3187594beced88d4921}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!Generic\+Set@{Generic\+Set}}
\index{Generic\+Set@{Generic\+Set}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{Generic\+Set()}{GenericSet()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \subsubsection*{Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set; }

Initializes an empty set of the specified element type. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a6bac19c4194012a2724702caf3a15e20}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a6bac19c4194012a2724702caf3a15e20}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!Generic\+Set@{Generic\+Set}}
\index{Generic\+Set@{Generic\+Set}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{Generic\+Set()}{GenericSet()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} $>$}]{list }\end{DoxyParamCaption})}



Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} \subsubsection*{Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set \{1, 2, 3\}; }

Initializes a new set that stores the given elements. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_abcd375e42dcb08298b04d3425d2b95d7}\label{classstanfordcpplib_1_1collections_1_1GenericSet_abcd375e42dcb08298b04d3425d2b95d7}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!Generic\+Set@{Generic\+Set}}
\index{Generic\+Set@{Generic\+Set}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{Generic\+Set()}{GenericSet()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} (\begin{DoxyParamCaption}\item[{Args...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set(... 

\subsubsection*{things for the map ...); }

Forwards the specified arguments down to the underlying \mbox{\hyperlink{classMap}{Map}} type. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_aae5f987c2f3dc9708bed63dd9c80b5fa}\label{classstanfordcpplib_1_1collections_1_1GenericSet_aae5f987c2f3dc9708bed63dd9c80b5fa}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!Generic\+Set@{Generic\+Set}}
\index{Generic\+Set@{Generic\+Set}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{Generic\+Set()}{GenericSet()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} $>$}]{list,  }\item[{Args...}]{args }\end{DoxyParamCaption})}



Constructor\+: \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} Usage\+: Generic\+Set$<$\+Value\+Type, Set\+Traits$>$ set(\{1, 2, 3\}, ... 

\subsubsection*{things for the map ...); }

Constructs a set using the specified elements, forwarding the arguments to the underlying map. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ab221b36dcc150632e4f355130d16f377}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ab221b36dcc150632e4f355130d16f377}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!````~Generic\+Set@{$\sim$\+Generic\+Set}}
\index{````~Generic\+Set@{$\sim$\+Generic\+Set}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{$\sim$\+Generic\+Set()}{~GenericSet()}}
{\footnotesize\ttfamily virtual $\sim$\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}



\subsubsection*{Destructor\+: $\sim$\+Set }

Frees any heap storage associated with this set. 



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a7cfcf4823a6ebadb0244d0943e5ea727}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a7cfcf4823a6ebadb0244d0943e5ea727}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!add@{add}}
\index{add@{add}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{add()}{add()}}
{\footnotesize\ttfamily void add (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})}



Method\+: add \subsubsection*{Usage\+: set.\+add(value); }

Adds an element to this set, if it was not already there. 

For compatibility with the S\+TL {\ttfamily set} class, this method is also exported as {\ttfamily insert}. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ad7f4cd8986fd068b79d2a69a79348a7e}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ad7f4cd8986fd068b79d2a69a79348a7e}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!add\+All@{add\+All}}
\index{add\+All@{add\+All}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{add\+All()}{addAll()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& add\+All (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})}



Method\+: add\+All \subsubsection*{Usage\+: set.\+add\+All(set2); }

Adds all elements of the given other set to this set. 

You can also pass an initializer list such as \{1, 2, 3\}. Returns a reference to this set.

\mbox{\hyperlink{classNote}{Note}} that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the + operator instead (not +=), which returns a newly created copy set.

Identical in behavior to the += operator. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a4b351b4cfc065bb0eee5d8c7404c3147}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a4b351b4cfc065bb0eee5d8c7404c3147}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!back@{back}}
\index{back@{back}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{back()}{back()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$\+::\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Method\+: back \subsubsection*{Usage\+: Value\+Type value = set.\+back(); }

Returns the last value in the set in the order established by the {\ttfamily foreach} macro. 

If the set is empty, generates an error. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a0c62c15c8ed609e7e5e9518cf5f5c712}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a0c62c15c8ed609e7e5e9518cf5f5c712}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!begin@{begin}}
\index{begin@{begin}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{begin()}{begin()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}{iterator}} begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ac8bb3912a3ce86b15842e79d0b421204}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ac8bb3912a3ce86b15842e79d0b421204}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!clear@{clear}}
\index{clear@{clear}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Method\+: clear \subsubsection*{Usage\+: set.\+clear(); }

Removes all elements from this set. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a9b67116c496b2347931664ac27c37921}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a9b67116c496b2347931664ac27c37921}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!contains@{contains}}
\index{contains@{contains}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{contains()}{contains()}}
{\footnotesize\ttfamily bool contains (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption}) const}



Method\+: contains Usage\+: if (set.\+contains(value)) ... 



 Returns {\ttfamily true} if the specified value is in this set. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_abaa27e9ac99d4d889625d3989b40f0b6}\label{classstanfordcpplib_1_1collections_1_1GenericSet_abaa27e9ac99d4d889625d3989b40f0b6}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!contains\+All@{contains\+All}}
\index{contains\+All@{contains\+All}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{contains\+All()}{containsAll()}}
{\footnotesize\ttfamily bool contains\+All (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Method\+: contains\+All Usage\+: if (set.\+contains\+All(set2)) ... 



 Returns {\ttfamily true} if every value from the given other set is also found in this set. You can also pass an initializer list such as \{1, 2, 3\}. Equivalent in behavior to is\+Superset\+Of. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_af6112917491bf7803154d808ad93518d}\label{classstanfordcpplib_1_1collections_1_1GenericSet_af6112917491bf7803154d808ad93518d}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!difference@{difference}}
\index{difference@{difference}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{difference()}{difference()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& difference (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})}



Method\+: difference \subsubsection*{Usage\+: set.\+difference(set2); }

Removes all elements of the given other set from this set. 

You can also pass an initializer list such as \{1, 2, 3\}. Returns a reference to this set.

\mbox{\hyperlink{classNote}{Note}} that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the -\/ operator instead (not -\/=), which returns a newly created copy set.

Identical in behavior to the -\/= operator and the remove\+All function. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a68b688a51bd0cf6fb5bc2cba292209a8}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a68b688a51bd0cf6fb5bc2cba292209a8}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!end@{end}}
\index{end@{end}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{end()}{end()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_ab3d10e70baaeac78e76b7abae7e2cf76}{iterator}} end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_af0f6c12b7eb171e7b5e3725f04f3c1f3}\label{classstanfordcpplib_1_1collections_1_1GenericSet_af0f6c12b7eb171e7b5e3725f04f3c1f3}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!equals@{equals}}
\index{equals@{equals}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{equals()}{equals()}}
{\footnotesize\ttfamily bool equals (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Method\+: equals Usage\+: if (set.\+equals(set2)) ... 



 Returns {\ttfamily true} if this set contains exactly the same values as the given other set. Identical in behavior to the == operator. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a645a432ab2e8069945e37c3adc9a7ff5}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a645a432ab2e8069945e37c3adc9a7ff5}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!first@{first}}
\index{first@{first}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{first()}{first()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$\+::\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} first (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Method\+: first \subsubsection*{Usage\+: Value\+Type value = set.\+first(); }

Returns the first value in the set in the order established by the {\ttfamily foreach} macro. 

If the set is empty, {\ttfamily first} generates an error. Equivalent to front. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a9c9f0cc6419ef7e036df4eeac4825b2c}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a9c9f0cc6419ef7e036df4eeac4825b2c}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!front@{front}}
\index{front@{front}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{front()}{front()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$\+::\mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Method\+: front \subsubsection*{Usage\+: Value\+Type value = set.\+front(); }

Returns the first value in the set in the order established by the {\ttfamily foreach} macro. 

If the set is empty, generates an error. Equivalent to first. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_aa81ff41776176f38b1a5c616f1815831}\label{classstanfordcpplib_1_1collections_1_1GenericSet_aa81ff41776176f38b1a5c616f1815831}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!insert@{insert}}
\index{insert@{insert}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily void insert (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})}



Method\+: insert \subsubsection*{Usage\+: set.\+insert(value); }

Adds an element to this set, if it was not already there. 

This method is exported for compatibility with the S\+TL {\ttfamily set} class. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a1892695645d8f29cbc6c8587500f2829}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a1892695645d8f29cbc6c8587500f2829}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!intersect@{intersect}}
\index{intersect@{intersect}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{intersect()}{intersect()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& intersect (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})}



Method\+: intersect \subsubsection*{Usage\+: set.\+intersect(set2); }

Removes all elements from this set that are not contained in the given other set. 

You can also pass an initializer list such as \{1, 2, 3\}. Returns a reference to this set.

\mbox{\hyperlink{classNote}{Note}} that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the $\ast$ operator instead (not $\ast$=), which returns a newly created copy set.

Identical in behavior to the $\ast$= operator and the retain\+All function. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_acf82f9b2937375c7b1cf3dccb3df3312}\label{classstanfordcpplib_1_1collections_1_1GenericSet_acf82f9b2937375c7b1cf3dccb3df3312}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!is\+Empty@{is\+Empty}}
\index{is\+Empty@{is\+Empty}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{is\+Empty()}{isEmpty()}}
{\footnotesize\ttfamily bool is\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Method\+: is\+Empty Usage\+: if (set.\+is\+Empty()) ... 



 Returns {\ttfamily true} if this set contains no elements. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_af8ce41f03d31f89935db1f3f5fdffc2c}\label{classstanfordcpplib_1_1collections_1_1GenericSet_af8ce41f03d31f89935db1f3f5fdffc2c}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!is\+Subset\+Of@{is\+Subset\+Of}}
\index{is\+Subset\+Of@{is\+Subset\+Of}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{is\+Subset\+Of()}{isSubsetOf()}}
{\footnotesize\ttfamily bool is\+Subset\+Of (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Method\+: is\+Subset\+Of Usage\+: if (set.\+is\+Subset\+Of(set2)) ... 



 Implements the subset relation on sets. It returns {\ttfamily true} if every element of this set is contained in {\ttfamily set2}. You can also pass an initializer list such as \{1, 2, 3\}. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a074ab19fab73dfcff220d4b64aa5be82}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a074ab19fab73dfcff220d4b64aa5be82}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!is\+Superset\+Of@{is\+Superset\+Of}}
\index{is\+Superset\+Of@{is\+Superset\+Of}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{is\+Superset\+Of()}{isSupersetOf()}}
{\footnotesize\ttfamily bool is\+Superset\+Of (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Method\+: is\+Superset\+Of Usage\+: if (set.\+is\+Superset\+Of(set2)) ... 



 Implements the superset relation on sets. It returns {\ttfamily true} if every element of this set is contained in {\ttfamily set2}. You can also pass an initializer list such as \{1, 2, 3\}. Equivalent in behavior to contains\+All. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_af2ca00030776c68af16559092a3856a4}\label{classstanfordcpplib_1_1collections_1_1GenericSet_af2ca00030776c68af16559092a3856a4}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!map\+All@{map\+All}}
\index{map\+All@{map\+All}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{map\+All()}{mapAll()}}
{\footnotesize\ttfamily void map\+All (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&)$>$}]{fn }\end{DoxyParamCaption}) const}



Method\+: map\+All \subsubsection*{Usage\+: set.\+map\+All(fn); }

Iterates through the elements of the set and calls {\ttfamily fn(value)} for each one. 

The iteration order matches the underlying order in which the elements are stored. For Set, this is sorted order according to the comparison function; for Linked\+Hash\+Set, this is the insertion order; and for Hash\+Set, this is whatever order the elements happen to be in. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a2da26ab6a8320bed56ef83210a0addf8}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a2da26ab6a8320bed56ef83210a0addf8}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily bool operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Operator\+: != \subsubsection*{Usage\+: set1 != set2 }

Returns {\ttfamily true} if {\ttfamily set1} and {\ttfamily set2} are different. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a834d22cfc42c67b0243283c3bc02ce5e}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a834d22cfc42c67b0243283c3bc02ce5e}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator$\ast$()}{operator*()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ operator$\ast$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Operator\+: $\ast$ \subsubsection*{Usage\+: set1 $\ast$ set2 }

Returns the intersection of sets {\ttfamily set1} and {\ttfamily set2}, which is the set of all elements that appear in both. 

You can also pass an initializer list such as \{1, 2, 3\}. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a1528986f737cd2163e1361e0bf326957}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a1528986f737cd2163e1361e0bf326957}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator$\ast$=()}{operator*=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& operator$\ast$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption})}



Operator\+: $\ast$= \subsubsection*{Usage\+: set1 $\ast$= set2; }

Removes any elements from {\ttfamily set1} that are not present in {\ttfamily set2}. 

You can also pass an initializer list such as \{1, 2, 3\}. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_afea3af6c9d038b2965e152623d790723}\label{classstanfordcpplib_1_1collections_1_1GenericSet_afea3af6c9d038b2965e152623d790723}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator+@{operator+}}
\index{operator+@{operator+}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Operator\+: + Usage\+: set1 + set2 \subsubsection*{set1 + element }

Returns the union of sets {\ttfamily set1} and {\ttfamily set2}, which is the set of elements that appear in at least one of the two sets. 

You can also pass an initializer list such as \{1, 2, 3\}. The right hand set can be replaced by an element of the value type, in which case the operator returns a new set formed by adding that element. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_afa15583f3e2d538799d56f6ac04608b9}\label{classstanfordcpplib_1_1collections_1_1GenericSet_afa15583f3e2d538799d56f6ac04608b9}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator+@{operator+}}
\index{operator+@{operator+}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator+()}{operator+()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ operator+ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{element }\end{DoxyParamCaption}) const}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_af79734e82170dc5c5c9304a9d1898d57}\label{classstanfordcpplib_1_1collections_1_1GenericSet_af79734e82170dc5c5c9304a9d1898d57}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator+=()}{operator+=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& operator+= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption})}



~\newline
 Operator\+: += Usage\+: set1 += set2; \subsubsection*{set1 += value; }

Adds all of the elements from {\ttfamily set2} (or the single specified value) to {\ttfamily set1}. 

You can also pass an initializer list such as \{1, 2, 3\}. As a convenience, the {\ttfamily Set} package also overloads the comma operator so that it is possible to initialize a set like this\+:


\begin{DoxyPre}
     Set<int> digits;
     digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
*\end{DoxyPre}
 \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a47b0925fd317fb30201e28139c7370e5}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a47b0925fd317fb30201e28139c7370e5}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator+=()}{operator+=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& operator+= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ad2860c6b9af5560b816dd9f10dc13f27}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ad2860c6b9af5560b816dd9f10dc13f27}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator,@{operator,}}
\index{operator,@{operator,}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator,()}{operator,()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}\& operator, (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a5996e7e22f84d81f44c2402c2493d43b}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a5996e7e22f84d81f44c2402c2493d43b}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator-\/()}{operator-()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Operator\+: -\/ Usage\+: set1 -\/ set2 \subsubsection*{set1 -\/ element }

Returns the difference of sets {\ttfamily set1} and {\ttfamily set2}, which is all of the elements that appear in {\ttfamily set1} but not {\ttfamily set2}. 

You can also pass an initializer list such as \{1, 2, 3\}. The right hand set can be replaced by an element of the value type, in which case the operator returns a new set formed by removing that element. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a4c09cbefc6834fc9010e209c8ce90765}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a4c09cbefc6834fc9010e209c8ce90765}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator-\/()}{operator-()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ operator-\/ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{element }\end{DoxyParamCaption}) const}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_adffcff306f0a21b87fc0eb99343a2719}\label{classstanfordcpplib_1_1collections_1_1GenericSet_adffcff306f0a21b87fc0eb99343a2719}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator-\/=@{operator-\/=}}
\index{operator-\/=@{operator-\/=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator-\/=()}{operator-=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& operator-\/= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption})}



~\newline
 Operator\+: -\/= Usage\+: set1 -\/= set2; \subsubsection*{set1 -\/= value; }

Removes the elements from {\ttfamily set2} (or the single specified value) from {\ttfamily set1}. 

You can also pass an initializer list such as \{1, 2, 3\}. As a convenience, the {\ttfamily Set} package also overloads the comma operator so that it is possible to remove multiple elements from a set like this\+:


\begin{DoxyPre}
     digits -= 0, 2, 4, 6, 8;
*\end{DoxyPre}


which removes the values 0, 2, 4, 6, and 8 from the set {\ttfamily digits}. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a6c4b3d414008341cbea6e24f14a2ee11}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a6c4b3d414008341cbea6e24f14a2ee11}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator-\/=@{operator-\/=}}
\index{operator-\/=@{operator-\/=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator-\/=()}{operator-=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& operator-\/= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a7f956a22921c1683b74783b055bbb2b5}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a7f956a22921c1683b74783b055bbb2b5}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator==@{operator==}}
\index{operator==@{operator==}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily bool operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set2 }\end{DoxyParamCaption}) const}



Operator\+: == \subsubsection*{Usage\+: set1 == set2 }

Returns {\ttfamily true} if {\ttfamily set1} and {\ttfamily set2} contain the same elements. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ab522af639e5f45b032943bc611de79db}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ab522af639e5f45b032943bc611de79db}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!remove@{remove}}
\index{remove@{remove}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{remove()}{remove()}}
{\footnotesize\ttfamily void remove (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet_a669c81f158766925e7293f97c0099b28}{value\+\_\+type}} \&}]{value }\end{DoxyParamCaption})}



Method\+: remove \subsubsection*{Usage\+: set.\+remove(value); }

Removes an element from this set. 

If the value was not contained in the set, no error is generated and the set remains unchanged. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a59fc29f868cd2ce2668788198e8a05a7}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a59fc29f868cd2ce2668788198e8a05a7}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!remove\+All@{remove\+All}}
\index{remove\+All@{remove\+All}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{remove\+All()}{removeAll()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& remove\+All (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})}



Method\+: remove\+All \subsubsection*{Usage\+: set.\+remove\+All(set2); }

Removes all elements of the given other set from this set. 

You can also pass an initializer list such as \{1, 2, 3\}. Returns a reference to this set.

\mbox{\hyperlink{classNote}{Note}} that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the -\/ operator instead (not -\/=), which returns a newly created copy set.

Identical in behavior to the -\/= operator and the difference function. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a15b39be914ac3e2ecb6f0d14ab893f9a}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a15b39be914ac3e2ecb6f0d14ab893f9a}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!retain\+All@{retain\+All}}
\index{retain\+All@{retain\+All}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{retain\+All()}{retainAll()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& retain\+All (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})}



Method\+: retain\+All \subsubsection*{Usage\+: set.\+retain\+All(set2); }

Removes all elements from this set that are not contained in the given other set. 

You can also pass an initializer list such as \{1, 2, 3\}. Returns a reference to this set.

\mbox{\hyperlink{classNote}{Note}} that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the $\ast$ operator instead (not $\ast$=), which returns a newly created copy set.

Identical in behavior to the $\ast$= operator and the intersect function. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_af9593d4a5ff4274efaf429cb4f9e57cc}\label{classstanfordcpplib_1_1collections_1_1GenericSet_af9593d4a5ff4274efaf429cb4f9e57cc}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!size@{size}}
\index{size@{size}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily int size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Method\+: size \subsubsection*{Usage\+: count = set.\+size(); }

Returns the number of elements in this set. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a1fe5121d6528fdea3f243321b3fa3a49}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a1fe5121d6528fdea3f243321b3fa3a49}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!to\+String@{to\+String}}
\index{to\+String@{to\+String}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{to\+String()}{toString()}}
{\footnotesize\ttfamily std\+::string to\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Method\+: to\+String \subsubsection*{Usage\+: string str = set.\+to\+String(); }

Converts the set to a printable string representation. 

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_affa3b4d177e1794dbb3e6a414a5ec2b3}\label{classstanfordcpplib_1_1collections_1_1GenericSet_affa3b4d177e1794dbb3e6a414a5ec2b3}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!union\+With@{union\+With}}
\index{union\+With@{union\+With}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{union\+With()}{unionWith()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \& union\+With (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})}



Method\+: union\+With \subsubsection*{Usage\+: set.\+union\+With(set2); }

Adds all elements of the given other set to this set. 

You can also pass an initializer list such as \{1, 2, 3\}. Returns a reference to this set. Identical in behavior to the += operator and the add\+All function.

\mbox{\hyperlink{classNote}{Note}} that this function modifies the current set in place rather than returning a new set. If you want a new set, consider using the + operator instead (not +=), which returns a newly created copy set.

(Implementation note\+: This function cannot be named \textquotesingle{}union\textquotesingle{} because that is a C/\+C++ keyword.) 

\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a0e54ba06df831323f5a7743ada2de6be}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a0e54ba06df831323f5a7743ada2de6be}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!hash\+Code@{hash\+Code}}
\index{hash\+Code@{hash\+Code}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{hash\+Code}{hashCode}}
{\footnotesize\ttfamily int hash\+Code (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ \mbox{\hyperlink{structstanfordcpplib_1_1collections_1_1SetTraits}{Set\+Traits}} $>$ \&}]{set }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_ab2c038f3c2f75cc78c062f0b3b16a411}\label{classstanfordcpplib_1_1collections_1_1GenericSet_ab2c038f3c2f75cc78c062f0b3b16a411}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator$<$}{operator<}}
{\footnotesize\ttfamily bool operator$<$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set1,  }\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



Operators\+: $<$, $>$, $<$=, $>$= Usage\+: if (set1 $<$= set2) ... 

\subsubsection*{... }

Relational operators to compare two sets. The $<$, $>$, $<$=, $>$= operators require that the value type has a $<$ operator so that the elements can be compared pairwise.

These are implemented as friend functions so that if we fully instantiate this type, we don\textquotesingle{}t get errors when using relational operators. \mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a65e20d362dfabf8b6592439af08e9c45}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a65e20d362dfabf8b6592439af08e9c45}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator$<$=}{operator<=}}
{\footnotesize\ttfamily bool operator$<$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set1,  }\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_add56ec57acd73fce18db96d132e25212}\label{classstanfordcpplib_1_1collections_1_1GenericSet_add56ec57acd73fce18db96d132e25212}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator$>$}{operator>}}
{\footnotesize\ttfamily bool operator$>$ (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set1,  }\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

\mbox{\Hypertarget{classstanfordcpplib_1_1collections_1_1GenericSet_a82f6e70e1615f32c9c24620b911d5806}\label{classstanfordcpplib_1_1collections_1_1GenericSet_a82f6e70e1615f32c9c24620b911d5806}} 
\index{stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!stanfordcpplib\+::collections\+::\+Generic\+Set@{stanfordcpplib\+::collections\+::\+Generic\+Set}}
\subsubsection{\texorpdfstring{operator$>$=}{operator>=}}
{\footnotesize\ttfamily bool operator$>$= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set1,  }\item[{const \mbox{\hyperlink{classstanfordcpplib_1_1collections_1_1GenericSet}{Generic\+Set}}$<$ Traits $>$ \&}]{set2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

